<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="description" content="FP -&gt; Compilers -&gt; Logic -&gt; Blog">
    <meta name="author" content="Luc Tielen">
    <meta name=viewport content="width=device-width, initial-scale=1">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@luctielen">
<meta name="twitter:creator" content="@luctielen">
<meta name="twitter:title" content="Create recursion-schemes using comonads">
    <meta name="twitter:description" content="">
    <meta name="twitter:image" content="https://luctielen.com/images/recursion-schemes-using-comonads.png">
    <title>Create recursion-schemes using comonads</title>
    <link rel="icon" type="image/svg+xml" href="/images/favicon.svg" />
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Amaranth&family=Titillium+Web&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">
    <script defer data-domain="luctielen.com" src="https://plausible.io/js/plausible.js"></script>
  </head>
</head>
<body>
  <header>
    <nav>
      <a href="/">Blog</a>
      <a href="/videos">Videos</a>
      <a href="/about">About</a>
      <div class="social">
        <a href="https://twitter.com/luctielen">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 16 16"
          width="16"
          height="16"
        >
          <path
            d="M16 3.538a6.461 6.461 0 01-1.884.516 3.301 3.301 0 001.444-1.816 6.607 6.607 0 01-2.084.797 3.28 3.28 0 00-2.397-1.034 3.28 3.28 0 00-3.197 4.028 9.321 9.321 0 01-6.766-3.431 3.284 3.284 0 001.015 4.381A3.301 3.301 0 01.643 6.57v.041A3.283 3.283 0 003.277 9.83a3.291 3.291 0 01-1.485.057 3.293 3.293 0 003.066 2.281 6.586 6.586 0 01-4.862 1.359 9.286 9.286 0 005.034 1.475c6.037 0 9.341-5.003 9.341-9.341 0-.144-.003-.284-.009-.425a6.59 6.59 0 001.637-1.697z"
          />
        </svg>
      </a>
       
      <a href="https://github.com/luc-tielen">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 16 16"
          width="16"
          height="16"
        >
          <path
            d="M8 .198a8 8 0 00-2.529 15.591c.4.074.547-.174.547-.385 0-.191-.008-.821-.011-1.489-2.226.484-2.695-.944-2.695-.944-.364-.925-.888-1.171-.888-1.171-.726-.497.055-.486.055-.486.803.056 1.226.824 1.226.824.714 1.223 1.872.869 2.328.665.072-.517.279-.87.508-1.07-1.777-.202-3.645-.888-3.645-3.954 0-.873.313-1.587.824-2.147-.083-.202-.357-1.015.077-2.117 0 0 .672-.215 2.201.82A7.672 7.672 0 018 4.066c.68.003 1.365.092 2.004.269 1.527-1.035 2.198-.82 2.198-.82.435 1.102.162 1.916.079 2.117.513.56.823 1.274.823 2.147 0 3.073-1.872 3.749-3.653 3.947.287.248.543.735.543 1.481 0 1.07-.009 1.932-.009 2.195 0 .213.144.462.55.384A8 8 0 008.001.196z"
          />
        </svg>
      </a>
       
      <a href="https://www.youtube.com/channel/UCeMz1NwTQlkhQvIFYMZoAJQ">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
        >
          <path
            d="M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z"
          />
        </svg>
      </a>
      <a href="/atom.xml">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 16 16"
            width="16"
            height="16"
          >
            <path
              d="M2.13 11.733c-1.175 0-2.13.958-2.13 2.126 0 1.174.955 2.122 2.13 2.122a2.126 2.126 0 002.133-2.122 2.133 2.133 0 00-2.133-2.126zM.002 5.436v3.067c1.997 0 3.874.781 5.288 2.196a7.45 7.45 0 012.192 5.302h3.08c0-5.825-4.739-10.564-10.56-10.564zM.006 0v3.068C7.128 3.068 12.924 8.87 12.924 16H16C16 7.18 8.824 0 .006 0z"
            />
          </svg>
        </a>
      </div>
    </nav>
  </header>
  <main class="post">
    <h1>Create recursion-schemes using comonads</h1>
    <!--
    <span class="date"></span>
    -->
    <div class="tags">
      <span class="tag tag-haskell"><a href="/tag/haskell">haskell</a></span>
    </div>
    <img class="post-image" src="/images/recursion-schemes-using-comonads.png"/>
    <p>In today's post, I explain how comonads can be used to create a tailor-made recursion scheme to perform computations based on multiple simultaneous folds over a single recursive data type.</p>
<p>The technique is based on the theoretical heavy paper named <a href="https://www.semanticscholar.org/paper/Recursion-Schemes-from-Comonads-Uustalu-Vene/d9a0b1804341c03bd3cae678c363e4ec317257b5?p2df">"Recursion Schemes from Comonads"</a>, but I will try to explain it as much as possible in an approachable way from a pragmatic point of view. I will assume some familiarity with Haskell and the <a href="https://hackage.haskell.org/package/recursion-schemes">recursion-schemes library</a> though, to avoid this article from exploding in size. If you are interested and want to learn more about the nitty-gritty details of the recursion-schemes library explained in an accessible way, I can recommend <a href="https://blog.sumtypeofway.com/posts/introduction-to-recursion-schemes.html">Patrick Thomson's great 6-part series of recursion-scheme blogposts</a>.</p>
<h2 id="the-case-for-generalized-recursion-schemes">The case for generalized recursion schemes</h2>
<p>Before I explain the technique, I have to point out that most usecases can probably be covered by an already existing recursion scheme provided by the <code>recursion-schemes</code> library. Always try to use an existing scheme where possible, since it is just much simpler and easier to maintain over time!</p>
<p>However, recently when I was working on my Datalog compiler, I ran into some situations where functions like <code>zygo</code> and <code>para</code> would not be powerful enough. I'd notice this when I had to do a lot of additional "bookkeeping" and maintain a lot of extra state in the fold itself. If you notice yourself that you are running into a similar situation when writing code that uses <code>recursion-schemes</code>, that might be a signal you need to upgrade to a custom-built scheme.</p>
<h2 id="creating-a-custom-recursion-scheme">Creating a custom recursion scheme</h2>
<p>If we search through the recursion-schemes library, we come across a <code>gcata</code> function (short for generalized catamorphism or fold) with a <em>gnarly</em> type signature:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="ot">gcata ::</span> (<span class="dt">Recursive</span> t, <span class="dt">Comonad</span> w)</span>
<span id="cb1-2"><a href="#cb1-2"></a>      <span class="co">-- A &quot;distributive law&quot;:</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>      <span class="ot">=&gt;</span> (<span class="kw">forall</span> b<span class="op">.</span> <span class="dt">Base</span> t (w b) <span class="ot">-&gt;</span> w (<span class="dt">Base</span> t b))</span>
<span id="cb1-4"><a href="#cb1-4"></a>      <span class="co">-- A (Base t)-w-algebra:</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>      <span class="ot">-&gt;</span> (<span class="dt">Base</span> t (w a) <span class="ot">-&gt;</span> a)</span>
<span id="cb1-6"><a href="#cb1-6"></a>      <span class="co">-- A structure to recurse over and collect results:</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>      <span class="ot">-&gt;</span> t</span>
<span id="cb1-8"><a href="#cb1-8"></a>      <span class="co">-- The result:</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>      <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>The signature tells us the following: if we pass in a "distributive law" that describes what actions to perform at each node of a recursive datastructure, and if we pass in an algebra for transforming a single layer of a recursive structure to a value, then we can fold down the entire recursive structure down to a single result value.</p>
<p>The <code>recursion-schemes</code> library provides us with many distributive laws and even distributive law <em>transformers</em> for composing these distributive laws (e.g. <code>distZygoT</code>, <code>distPara</code>). If you pass in one of these values to <code>gcata</code>, the resulting behavior of the function will adapt itself:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">-- distZygoT + distPara gives us a recursion scheme:</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="co">-- 1. f is a helper algebra for computing a value &quot;b&quot;</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="co">-- 2. g is a algebra that gives access to &quot;b&quot;, the original structure &quot;t&quot;</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="co">--    and can be used to compute an &quot;a&quot;</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>example</span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="ot">  ::</span> (<span class="dt">Recursive</span> t, <span class="dt">Corecursive</span> t)</span>
<span id="cb2-7"><a href="#cb2-7"></a>  <span class="ot">=&gt;</span> (<span class="dt">Base</span> t b <span class="ot">-&gt;</span> b)</span>
<span id="cb2-8"><a href="#cb2-8"></a>  <span class="ot">-&gt;</span> (<span class="dt">Base</span> t (<span class="dt">EnvT</span> b ((,) t) a) <span class="ot">-&gt;</span> a)</span>
<span id="cb2-9"><a href="#cb2-9"></a>  <span class="ot">-&gt;</span> t</span>
<span id="cb2-10"><a href="#cb2-10"></a>  <span class="ot">-&gt;</span> a</span>
<span id="cb2-11"><a href="#cb2-11"></a>example f g <span class="ot">=</span> gcata (distZygoT f distPara) g</span></code></pre></div>
<p>These distributive law combinators get us <em>really far</em>. But for my usecase, this still wasn't enough. I needed to write a compiler pass, where I needed to do 2 helper folds and 1 final fold that had access to the results of the previous 2 folds. On top of that, both the final fold and one of the helper folds needed access to the original recursive structure for some computations. So let's see how we can create a recursion scheme to do just that.</p>
<p>Since the distributive law argument passed to <code>gcata</code> can make use of any <code>Comonad</code>, we can introduce our own datastructure to create exactly the behavior we need. In the situation I just mentioned, the datastructure needs access to four distinct values:</p>
<ol>
<li>The original recursive datastructure,</li>
<li>The result from the first helper fold,</li>
<li>The result from the second helper fold,</li>
<li>The result from the final fold.</li>
</ol>
<p>Let's create a datastructure that helps us do just that:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">-- NOTE: Quad is isomorphic to a tuple with 4 elements (a, b, c, d).</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="co">-- We need a custom data type though, since the tuple type does not implement</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="co">-- Comonad.</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="kw">data</span> <span class="dt">Quad</span> a b c d</span>
<span id="cb3-5"><a href="#cb3-5"></a>  <span class="ot">=</span> <span class="dt">Quad</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>  {<span class="ot"> qFirst ::</span> a</span>
<span id="cb3-7"><a href="#cb3-7"></a>  ,<span class="ot"> qSecond ::</span> b</span>
<span id="cb3-8"><a href="#cb3-8"></a>  ,<span class="ot"> qThird ::</span> c</span>
<span id="cb3-9"><a href="#cb3-9"></a>  ,<span class="ot"> qFourth ::</span> d</span>
<span id="cb3-10"><a href="#cb3-10"></a>  } <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb3-11"><a href="#cb3-11"></a></span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="kw">instance</span> <span class="dt">Comonad</span> (<span class="dt">Quad</span> a b c) <span class="kw">where</span></span>
<span id="cb3-13"><a href="#cb3-13"></a>  extract (<span class="dt">Quad</span> _ _ _ d) <span class="ot">=</span> d</span>
<span id="cb3-14"><a href="#cb3-14"></a></span>
<span id="cb3-15"><a href="#cb3-15"></a>  duplicate (<span class="dt">Quad</span> a b c d) <span class="ot">=</span></span>
<span id="cb3-16"><a href="#cb3-16"></a>    <span class="dt">Quad</span> a b c (<span class="dt">Quad</span> a b c d)</span></code></pre></div>
<p>Next up, we need to write our own distributive law that makes use of the <code>Quad</code> data type. First of, here's the type signature, annotated with some comments:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a>distributiveLaw</span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="ot">  ::</span> <span class="dt">Corecursive</span> t</span>
<span id="cb4-3"><a href="#cb4-3"></a>  <span class="co">-- Given a first helper (Base t)-algebra:</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>  <span class="ot">=&gt;</span> (<span class="dt">Base</span> t a <span class="ot">-&gt;</span> a)</span>
<span id="cb4-5"><a href="#cb4-5"></a>  <span class="co">-- and a second helper (Base t)-algebra, which also has access to</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>  <span class="co">-- the original subtree &quot;t&quot;:</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>  <span class="ot">-&gt;</span> (<span class="dt">Base</span> t (t, b) <span class="ot">-&gt;</span> b)</span>
<span id="cb4-8"><a href="#cb4-8"></a>  <span class="co">-- then we get a distributive law that manages all the subresults</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>  <span class="co">-- using the Quad data type:</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>  <span class="ot">-&gt;</span> (<span class="dt">Base</span> t (<span class="dt">Quad</span> t a b c) <span class="ot">-&gt;</span> <span class="dt">Quad</span> t a b (<span class="dt">Base</span> t c))</span></code></pre></div>
<p>While this type signature is definitely complicated, it's actually quite straight-forward and mechanical to implement in a correct way using hole driven development. This is due to the fact that the types are so general and we only have a handful of functions (from the <code>Corecursive</code> and <code>Functor</code> type classes that we can use to transform the data.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a>distributiveLaw</span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="ot">  ::</span> <span class="dt">Corecursive</span> t</span>
<span id="cb5-3"><a href="#cb5-3"></a>  <span class="ot">=&gt;</span> (<span class="dt">Base</span> t a <span class="ot">-&gt;</span> a)</span>
<span id="cb5-4"><a href="#cb5-4"></a>  <span class="ot">-&gt;</span> (<span class="dt">Base</span> t (t, b) <span class="ot">-&gt;</span> b)</span>
<span id="cb5-5"><a href="#cb5-5"></a>  <span class="ot">-&gt;</span> (<span class="dt">Base</span> t (<span class="dt">Quad</span> t a b c) <span class="ot">-&gt;</span> <span class="dt">Quad</span> t a b (<span class="dt">Base</span> t c))</span>
<span id="cb5-6"><a href="#cb5-6"></a>distributiveLaw f g base_t_quad <span class="ot">=</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>  <span class="co">-- 1. we fmap an accessor function to only look at parts of `Quad`:</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>  <span class="kw">let</span> base_t_t <span class="ot">=</span> <span class="fu">fmap</span> qFirst base_t_quad</span>
<span id="cb5-9"><a href="#cb5-9"></a>      base_t_a <span class="ot">=</span> <span class="fu">fmap</span> qSecond base_t_quad</span>
<span id="cb5-10"><a href="#cb5-10"></a>      <span class="co">-- 2. `(&amp;&amp;&amp;)` + `qFirst` gives easy access to the original structure:</span></span>
<span id="cb5-11"><a href="#cb5-11"></a>      base_t_tb <span class="ot">=</span> <span class="fu">fmap</span> (qFirst <span class="op">&amp;&amp;&amp;</span> qThird) base_t_quad</span>
<span id="cb5-12"><a href="#cb5-12"></a>      base_t_c <span class="ot">=</span> <span class="fu">fmap</span> qFourth base_t_quad</span>
<span id="cb5-13"><a href="#cb5-13"></a>     <span class="co">-- 3. `embed` is used to get back the original recursive structure</span></span>
<span id="cb5-14"><a href="#cb5-14"></a>     <span class="co">-- 4. apply the helper algebras `f` and `g` to collect our sub-results</span></span>
<span id="cb5-15"><a href="#cb5-15"></a>  <span class="kw">in</span> <span class="dt">Quad</span> (embed base_t_t) (f base_t_a) (g base_t_tb) base_t_c</span></code></pre></div>
<p>And that's it! The function is dense, but the good thing is that the complexity is isolated to a small piece of code. Now that we have defined this distributive law, we could start using it together with <code>gcata</code> and 3 functions as follows:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a>example <span class="ot">=</span> gcata (distributiveLaw _helperAlgebra1 _helperAlgebra2) _algebra3</span></code></pre></div>
<p>If we try to visualize what's going on, we end up with something like the figure below. During a recursive bottom-up traversal, 3 functions are used to compute the results from the subtrees. These 3 results are combined with the node itself and stored in the <code>Quad</code> datatype, and passed onto the next level up in the tree.</p>
<p><img src="/images/recursion-schemes-using-comonads.png"
    height="300px"
    style="display: block; margin: auto; margin-bottom: 1em; margin-top: 1em;"
    /></p>
<p>As a final note, you can extend this technique to an N-ary tuple, allowing you to do N+1 simultaneous folds over a recursive structure. On top of that, the performance will still only be <code>O(n)</code> (with n equal to the size of the recursive structure), since the results from the subtrees are computed and collected on the fly while traversing the recursive structure. And since Haskell is lazy, if you don't use those sub-results, they won't even get evaluated!</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this post I showed how comonads in combination with the extremely general <code>gcata</code> function can be used to create tailor-made recursion schemes. By providing our own <code>Comonad</code> type and following a mechanical process for defining a distributive law, we can create a recursion scheme that does exactly what we need.</p>
<p>If you want to see a couple of places where I use this technique in action, you can look <a href="https://github.com/luc-tielen/eclair-lang/blob/0fa68eadb6f75b890f635a96d32469c3c761cedb/lib/Eclair/RA/Lower.hs#L83-L84">here for the actual code using <code>Quad</code></a> and <a href="https://github.com/luc-tielen/eclair-lang/blob/0fa68eadb6f75b890f635a96d32469c3c761cedb/lib/Eclair/EIR/Lower.hs#L162-L201">here for a similar example using <code>Triple</code> for LLVM code generation</a>. The technique proved to be very valuable, since the specialized recursion-scheme helped me structure the different moving parts of a complex pass in my Datalog compiler. Be warned though that both examples are not that straight-forward since they are quite large.</p>
<p>Finally, if you have any questions or thoughts about this article, let me know on <a href="https://twitter.com/luctielen">Twitter</a>.</p>
  </main>
</body>
