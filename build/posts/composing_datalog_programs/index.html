<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="description" content="FP -&gt; Compilers -&gt; Logic -&gt; Blog">
    <meta name="author" content="Luc Tielen">
    <meta name=viewport content="width=device-width, initial-scale=1">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@luctielen">
<meta name="twitter:creator" content="@luctielen">
<meta name="twitter:title" content="Composing Souffl√© analyses">
    <meta name="twitter:description" content="">
    <meta name="twitter:image" content="https://luctielen.com/images/analyses_are_arrows.png">
    <title>Composing Souffl√© analyses</title>
    <link rel="icon" type="image/png" href="/images/favicon.png">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Amaranth&family=Titillium+Web&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">
  </head>
</head>
<body>
  <header>
    <nav>
      <a href="/">Blog</a>
      <a href="/videos">Videos</a>
      <a href="/about">About</a>
      <div class="social">
        <a href="https://twitter.com/luctielen">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 16 16"
          width="16"
          height="16"
        >
          <path
            d="M16 3.538a6.461 6.461 0 01-1.884.516 3.301 3.301 0 001.444-1.816 6.607 6.607 0 01-2.084.797 3.28 3.28 0 00-2.397-1.034 3.28 3.28 0 00-3.197 4.028 9.321 9.321 0 01-6.766-3.431 3.284 3.284 0 001.015 4.381A3.301 3.301 0 01.643 6.57v.041A3.283 3.283 0 003.277 9.83a3.291 3.291 0 01-1.485.057 3.293 3.293 0 003.066 2.281 6.586 6.586 0 01-4.862 1.359 9.286 9.286 0 005.034 1.475c6.037 0 9.341-5.003 9.341-9.341 0-.144-.003-.284-.009-.425a6.59 6.59 0 001.637-1.697z"
          />
        </svg>
      </a>
       
      <a href="https://github.com/luc-tielen">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 16 16"
          width="16"
          height="16"
        >
          <path
            d="M8 .198a8 8 0 00-2.529 15.591c.4.074.547-.174.547-.385 0-.191-.008-.821-.011-1.489-2.226.484-2.695-.944-2.695-.944-.364-.925-.888-1.171-.888-1.171-.726-.497.055-.486.055-.486.803.056 1.226.824 1.226.824.714 1.223 1.872.869 2.328.665.072-.517.279-.87.508-1.07-1.777-.202-3.645-.888-3.645-3.954 0-.873.313-1.587.824-2.147-.083-.202-.357-1.015.077-2.117 0 0 .672-.215 2.201.82A7.672 7.672 0 018 4.066c.68.003 1.365.092 2.004.269 1.527-1.035 2.198-.82 2.198-.82.435 1.102.162 1.916.079 2.117.513.56.823 1.274.823 2.147 0 3.073-1.872 3.749-3.653 3.947.287.248.543.735.543 1.481 0 1.07-.009 1.932-.009 2.195 0 .213.144.462.55.384A8 8 0 008.001.196z"
          />
        </svg>
      </a>
       
      <a href="https://www.youtube.com/channel/UCeMz1NwTQlkhQvIFYMZoAJQ">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
        >
          <path
            d="M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z"
          />
        </svg>
      </a>
      <a href="/atom.xml">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 16 16"
            width="16"
            height="16"
          >
            <path
              d="M2.13 11.733c-1.175 0-2.13.958-2.13 2.126 0 1.174.955 2.122 2.13 2.122a2.126 2.126 0 002.133-2.122 2.133 2.133 0 00-2.133-2.126zM.002 5.436v3.067c1.997 0 3.874.781 5.288 2.196a7.45 7.45 0 012.192 5.302h3.08c0-5.825-4.739-10.564-10.56-10.564zM.006 0v3.068C7.128 3.068 12.924 8.87 12.924 16H16C16 7.18 8.824 0 .006 0z"
            />
          </svg>
        </a>
      </div>
    </nav>
  </header>
  <main class="post">
    <h1>Composing Souffl√© analyses</h1>
    <!--
    <span class="date"></span>
    -->
    <div class="tags">
      <span class="tag tag-haskell"><a href="/tag/haskell">haskell</a></span>
    </div>
    <img class="post-image" src="/images/analyses_are_arrows.png"/>
    <p>In today's post, I explore how we can use Haskell to compose multiple Souffl√© Datalog analyses in an elegant and principled way using various Haskell type-classes. No deep knowledge of Souffl√© Datalog or the <a href="https://github.com/luc-tielen/souffle-haskell">souffle-haskell library</a> is expected, but I do expect some familiarity with the more often used type-classes (Functor, Applicative, ...).</p>
<h2 id="the-analysis-data-type">The Analysis data type</h2>
<p>As a quick recap, the souffle-haskell library provides bindings for interacting with Souffl√© Datalog. All functionality is provided via a <code>SouffleM</code> monad, which focuses on a single Datalog analysis / program. Like I mentioned in my <a href="../static_analysis_using_haskell_and_datalog/">"Static analysis using Haskell and Datalog" blogpost</a>, an analysis consists of a few distinct parts:</p>
<ol>
<li>Find all relevant facts related to our Datalog analyses (in Haskell),</li>
<li>Explicitly "run" Souffl√© to compute all derived facts,</li>
<li>Collect all results back on the Haskell side.</li>
</ol>
<p>We can make this idea first-class by turning this into a Haskell datatype, giving us the following:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="co">-- NOTE: &quot;Handle prog&quot; is a type-safe handle of a Datalog program</span></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">data</span> <span class="dt">Analysis</span> prog input output</span>
<span id="cb1-4"><a href="#cb1-4"></a>  <span class="ot">=</span> <span class="dt">Analysis</span> (<span class="dt">Handle</span> prog <span class="ot">-&gt;</span> input <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> ())  <span class="co">-- finding facts</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>             (<span class="dt">Handle</span> prog <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> ())           <span class="co">-- running Souffl√©</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>             (<span class="dt">Handle</span> prog <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> output)       <span class="co">-- retrieving results</span></span></code></pre></div>
<p>Now that we have this new type, let's try writing some instances for it. First of, let's start with the <code>Functor</code> instance. This will make it possible to transform the result of an analysis:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Analysis</span> prog input) <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>  <span class="fu">fmap</span> f (<span class="dt">Analysis</span> find run get) <span class="ot">=</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    <span class="dt">Analysis</span> find run (<span class="fu">fmap</span> (<span class="fu">fmap</span> f) get)</span></code></pre></div>
<p>Besides <code>Functor</code>, we can also implement <code>Profunctor</code>. This gives us the ability to transform the input type of an analysis (using <code>lmap</code>):</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">instance</span> <span class="dt">Profunctor</span> (<span class="dt">Analysis</span> prog) <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>  lmap f (<span class="dt">Analysis</span> find run get) <span class="ot">=</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="dt">Analysis</span> (\h <span class="ot">-&gt;</span> lmap f (find h)) run get</span>
<span id="cb3-4"><a href="#cb3-4"></a></span>
<span id="cb3-5"><a href="#cb3-5"></a>  rmap <span class="ot">=</span> <span class="fu">fmap</span></span></code></pre></div>
<p><code>Semigroup</code> and <code>Monoid</code> instances are also possible, but they don't provide much additional value on top of what souffle-haskell already provides with the <code>SouffleM</code> monad. I chose to provide them anyway, because maybe somebody else has a good usecase for it (and the instances are straight-forward anyway) <span class="emoji" data-emoji="wink">üòâ</span>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">instance</span> <span class="dt">Semigroup</span> output <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">Analysis</span> prog input output) <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>  <span class="dt">Analysis</span> find1 run1 get1 <span class="op">&lt;&gt;</span> <span class="dt">Analysis</span> find2 run2 get2 <span class="ot">=</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="dt">Analysis</span> (find1 <span class="op">&lt;&gt;</span> find2) (run1 <span class="op">&lt;&gt;</span> run2) (get1 <span class="op">&lt;&gt;</span> get2)</span>
<span id="cb4-4"><a href="#cb4-4"></a></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="kw">instance</span> <span class="dt">Monoid</span> output <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Analysis</span> prog input output) <span class="kw">where</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">Analysis</span> <span class="fu">mempty</span> <span class="fu">mempty</span> <span class="fu">mempty</span></span></code></pre></div>
<p>Next up is <code>Applicative</code>. Implementing this for our <code>Analysis</code> type enables us to combine two different analyses from multiple Datalog programs with the same input type using applicative-style programming. We can try creating an instance for this type-class, but we would hit a snag when we try to use it. To find out why, take a look at the <code>(&lt;*&gt;)</code>-operator, specialized for our analysis type:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="ot">(&lt;*&gt;) ::</span> <span class="dt">Analysis</span> prog input (a <span class="ot">-&gt;</span> b)</span>
<span id="cb5-2"><a href="#cb5-2"></a>      <span class="ot">-&gt;</span> <span class="dt">Analysis</span> prog input  a</span>
<span id="cb5-3"><a href="#cb5-3"></a>      <span class="ot">-&gt;</span> <span class="dt">Analysis</span> prog input  b</span></code></pre></div>
<p>It may not be immediately obvious, but the <code>prog</code> type-variable has to be the same for both arguments passed to the operator! If you recall, this type-variable is used by the Handle type to keep track of the Datalog program it belongs to. Because the type-variable needs to stay the same for both arguments, we can't compose 2 different Datalog programs like this. We also can't get rid of this phantom type-variable, because this is what makes it possible for souffle-haskell to perform many compile-time checks as I explained in my post about <a href="../supercharge_your_handles_with_phantom_types">supercharging handles with phantom types</a>.</p>
<p>Luckily, we can circumvent this issue using a trick functional programmers often use: partial application. The trick is to close over the handle, so it no longer appears in our <code>Analysis</code> type, effectively hiding the type-variable. We can do this as follows:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="co">-- No more &#39;prog&#39; type variable!</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="kw">data</span> <span class="dt">Analysis</span> input output</span>
<span id="cb6-3"><a href="#cb6-3"></a>  <span class="ot">=</span> <span class="dt">Analysis</span> (input <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> ())</span>
<span id="cb6-4"><a href="#cb6-4"></a>             (<span class="dt">SouffleM</span> ())</span>
<span id="cb6-5"><a href="#cb6-5"></a>             (<span class="dt">SouffleM</span> output)</span>
<span id="cb6-6"><a href="#cb6-6"></a></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="co">-- An example that shows how to close over a handle in an Analysis:</span></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="ot">example ::</span> <span class="dt">Handle</span> prog <span class="ot">-&gt;</span> <span class="dt">Analysis</span> [<span class="dt">Edge</span>] [<span class="dt">Reachable</span>]</span>
<span id="cb6-9"><a href="#cb6-9"></a>example h <span class="ot">=</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>  <span class="dt">Analysis</span> (Souffle.addFacts h)</span>
<span id="cb6-11"><a href="#cb6-11"></a>           (Souffle.run h)</span>
<span id="cb6-12"><a href="#cb6-12"></a>           (Souffle.getFacts h)</span></code></pre></div>
<p>With this change we need to reimplement our previously defined instances though. By applying hole driven development, we quickly find the following implementations:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Analysis</span> input) <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>  <span class="fu">fmap</span> f (<span class="dt">Analysis</span> find run get) <span class="ot">=</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>    <span class="dt">Analysis</span> find run (<span class="fu">fmap</span> f get)</span>
<span id="cb7-4"><a href="#cb7-4"></a></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="kw">instance</span> <span class="dt">Profunctor</span> <span class="dt">Analysis</span> <span class="kw">where</span></span>
<span id="cb7-6"><a href="#cb7-6"></a>  lmap f (<span class="dt">Analysis</span> find run get) <span class="ot">=</span></span>
<span id="cb7-7"><a href="#cb7-7"></a>    <span class="dt">Analysis</span> (lmap f find) run get</span>
<span id="cb7-8"><a href="#cb7-8"></a></span>
<span id="cb7-9"><a href="#cb7-9"></a>  rmap <span class="ot">=</span> <span class="fu">fmap</span></span>
<span id="cb7-10"><a href="#cb7-10"></a></span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="co">-- NOTE: omitting Semigroup and Monoid, these have exactly</span></span>
<span id="cb7-12"><a href="#cb7-12"></a><span class="co">-- the same implementations as before.</span></span></code></pre></div>
<p>Now we can also implement <code>Applicative</code> without the composition issue mentioned earlier:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Analysis</span> input) <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>  <span class="fu">pure</span> a <span class="ot">=</span> <span class="dt">Analysis</span> <span class="fu">mempty</span> <span class="fu">mempty</span> (<span class="fu">pure</span> a)</span>
<span id="cb8-3"><a href="#cb8-3"></a></span>
<span id="cb8-4"><a href="#cb8-4"></a>  <span class="dt">Analysis</span> find1 run1 get1 <span class="op">&lt;*&gt;</span> <span class="dt">Analysis</span> find2 run2 get2 <span class="ot">=</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>    <span class="dt">Analysis</span> (find1 <span class="op">&lt;&gt;</span> find2) (run1 <span class="op">&lt;&gt;</span> run2) (get1 <span class="op">&lt;*&gt;</span> get2)</span></code></pre></div>
<p>As a quick side note, the behavior of this instance is very similar to what I described in my post about <a href="../combining_folds_using_semigroups">combining folds with semigroups</a>. For example, with a library like <a href="https://hackage.haskell.org/package/recursion-schemes">recursion-schemes</a>, a single fold can be performed to find all facts for multiple analyses.</p>
<h2 id="additional-forms-of-composition">Additional forms of composition</h2>
<p>We already achieved quite a bit so far with these first instances, but can we go further? One example that comes to mind is sequential composition. If we can think of a function where the output of one analysis forms the input of another, then it should be possible to execute them one after the other:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="ot">(?) ::</span> <span class="dt">Analysis</span> a b <span class="ot">-&gt;</span> <span class="dt">Analysis</span> b c <span class="ot">-&gt;</span> <span class="dt">Analysis</span> a c</span></code></pre></div>
<p>After some searching, this is the (flipped) <code>(.)</code>-operator (from <a href="">Control.Category</a>). However, if we try to implement <code>Category</code> for our analysis type, we run into an issue yet again. This time the issue is with the <code>id :: Analysis a a</code> "constant": for the third argument of the constructor, we can't construct a value of type <code>a</code> out of thin air!</p>
<p>All hope is not lost though. Just like before, we can do a small adjustment to our type (at the cost of rewriting the earlier defined instances all over again):</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">data</span> <span class="dt">Analysis</span> input output</span>
<span id="cb10-2"><a href="#cb10-2"></a>  <span class="ot">=</span> <span class="dt">Analysis</span> (input <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> ())</span>
<span id="cb10-3"><a href="#cb10-3"></a>             (<span class="dt">SouffleM</span> ())</span>
<span id="cb10-4"><a href="#cb10-4"></a>             (input <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> output)  <span class="co">-- input now also passed in here</span></span>
<span id="cb10-5"><a href="#cb10-5"></a></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="co">-- Helper function, results in same behavior as before.</span></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="ot">mkAnalysis ::</span> (input <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> ())</span>
<span id="cb10-8"><a href="#cb10-8"></a>           <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> ()</span>
<span id="cb10-9"><a href="#cb10-9"></a>           <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> output</span>
<span id="cb10-10"><a href="#cb10-10"></a>           <span class="ot">-&gt;</span> <span class="dt">Analysis</span> input output</span>
<span id="cb10-11"><a href="#cb10-11"></a>mkAnalysis find run get <span class="ot">=</span> <span class="dt">Analysis</span> find run (<span class="fu">const</span> get)</span>
<span id="cb10-12"><a href="#cb10-12"></a></span>
<span id="cb10-13"><a href="#cb10-13"></a><span class="co">-- The following instances are a good exercise for</span></span>
<span id="cb10-14"><a href="#cb10-14"></a><span class="co">-- honing your hole driven development skills:</span></span>
<span id="cb10-15"><a href="#cb10-15"></a></span>
<span id="cb10-16"><a href="#cb10-16"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Analysis</span> input) <span class="kw">where</span></span>
<span id="cb10-17"><a href="#cb10-17"></a>  <span class="fu">fmap</span> f (<span class="dt">Analysis</span> find run get) <span class="ot">=</span></span>
<span id="cb10-18"><a href="#cb10-18"></a>    <span class="dt">Analysis</span> find run (<span class="fu">fmap</span> (<span class="fu">fmap</span> f) get)</span>
<span id="cb10-19"><a href="#cb10-19"></a></span>
<span id="cb10-20"><a href="#cb10-20"></a><span class="kw">instance</span> <span class="dt">Profunctor</span> <span class="dt">Analysis</span> <span class="kw">where</span></span>
<span id="cb10-21"><a href="#cb10-21"></a>  lmap f (<span class="dt">Analysis</span> find run get) <span class="ot">=</span></span>
<span id="cb10-22"><a href="#cb10-22"></a>    <span class="dt">Analysis</span> (lmap f find) run (lmap f get)</span>
<span id="cb10-23"><a href="#cb10-23"></a></span>
<span id="cb10-24"><a href="#cb10-24"></a>  rmap <span class="ot">=</span> <span class="fu">fmap</span></span>
<span id="cb10-25"><a href="#cb10-25"></a></span>
<span id="cb10-26"><a href="#cb10-26"></a><span class="kw">instance</span> <span class="dt">Semigroup</span> output <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">Analysis</span> input output) <span class="kw">where</span></span>
<span id="cb10-27"><a href="#cb10-27"></a>  <span class="dt">Analysis</span> find1 run1 get1 <span class="op">&lt;&gt;</span> <span class="dt">Analysis</span> find2 run2 get2 <span class="ot">=</span></span>
<span id="cb10-28"><a href="#cb10-28"></a>    <span class="dt">Analysis</span> (find1 <span class="op">&lt;&gt;</span> find2) (run1 <span class="op">&lt;&gt;</span> run2) (get1 <span class="op">&lt;&gt;</span> get2)</span>
<span id="cb10-29"><a href="#cb10-29"></a></span>
<span id="cb10-30"><a href="#cb10-30"></a><span class="kw">instance</span> <span class="dt">Monoid</span> output <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Analysis</span> input output) <span class="kw">where</span></span>
<span id="cb10-31"><a href="#cb10-31"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">Analysis</span> <span class="fu">mempty</span> <span class="fu">mempty</span> <span class="fu">mempty</span></span>
<span id="cb10-32"><a href="#cb10-32"></a></span>
<span id="cb10-33"><a href="#cb10-33"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Analysis</span> input) <span class="kw">where</span></span>
<span id="cb10-34"><a href="#cb10-34"></a>  <span class="fu">pure</span> a <span class="ot">=</span> <span class="dt">Analysis</span> <span class="fu">mempty</span> <span class="fu">mempty</span> (<span class="fu">const</span> <span class="op">$</span> <span class="fu">pure</span> a)</span>
<span id="cb10-35"><a href="#cb10-35"></a></span>
<span id="cb10-36"><a href="#cb10-36"></a>  <span class="dt">Analysis</span> find1 run1 get1 <span class="op">&lt;*&gt;</span> <span class="dt">Analysis</span> find2 run2 get2 <span class="ot">=</span></span>
<span id="cb10-37"><a href="#cb10-37"></a>    <span class="dt">Analysis</span> (find1 <span class="op">&lt;&gt;</span> find2)</span>
<span id="cb10-38"><a href="#cb10-38"></a>             (run1 <span class="op">&lt;&gt;</span> run2)</span>
<span id="cb10-39"><a href="#cb10-39"></a>             (\input <span class="ot">-&gt;</span> get1 input <span class="op">&lt;*&gt;</span> get2 input)</span></code></pre></div>
<p>With this change, we can now implement <code>Category</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="co">-- NOTE: this function proves it is an isomorphism with `Kleisli SouffleM`</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="ot">execAnalysis ::</span> <span class="dt">Analysis</span> input output</span>
<span id="cb11-3"><a href="#cb11-3"></a>             <span class="ot">-&gt;</span> (input <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> output)</span>
<span id="cb11-4"><a href="#cb11-4"></a>execAnalysis (<span class="dt">Analysis</span> find run get) input <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-5"><a href="#cb11-5"></a>  find input</span>
<span id="cb11-6"><a href="#cb11-6"></a>  run</span>
<span id="cb11-7"><a href="#cb11-7"></a>  get input</span>
<span id="cb11-8"><a href="#cb11-8"></a></span>
<span id="cb11-9"><a href="#cb11-9"></a><span class="kw">instance</span> <span class="dt">Category</span> <span class="dt">Analysis</span> <span class="kw">where</span></span>
<span id="cb11-10"><a href="#cb11-10"></a>  <span class="fu">id</span> <span class="ot">=</span> <span class="dt">Analysis</span> <span class="fu">mempty</span> <span class="fu">mempty</span> <span class="fu">pure</span></span>
<span id="cb11-11"><a href="#cb11-11"></a></span>
<span id="cb11-12"><a href="#cb11-12"></a>  <span class="co">-- remember: right-to-left composition!</span></span>
<span id="cb11-13"><a href="#cb11-13"></a>  <span class="dt">Analysis</span> find2 run2 get2 <span class="op">.</span> <span class="dt">Analysis</span> find1 run1 get1 <span class="ot">=</span></span>
<span id="cb11-14"><a href="#cb11-14"></a>    <span class="dt">Analysis</span> find run2 get</span>
<span id="cb11-15"><a href="#cb11-15"></a>    <span class="kw">where</span></span>
<span id="cb11-16"><a href="#cb11-16"></a>      find <span class="ot">=</span> execAnalysis (<span class="dt">Analysis</span> find1 run1 get1) <span class="op">&gt;=&gt;</span> find2</span>
<span id="cb11-17"><a href="#cb11-17"></a>      get <span class="ot">=</span> get1 <span class="op">&gt;=&gt;</span> get2</span></code></pre></div>
<p>The <code>(.)</code>-operator is a little tricky to implement: we first have to make sure the first analysis has fully executed (all 3 parts), and only then can we start the second analysis. The fetching of results now also requires calling both <code>get1</code> and <code>get2</code>, but since we are using <code>const</code> in the <code>mkAnalysis</code> helper function, a second additional fetching of results (from <code>get1</code>) is skipped thanks to Haskell's built-in laziness.</p>
<p>This new definition of the <code>Analysis</code> type also makes it possible to implement <code>Arrow</code> and <code>ArrowChoice</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">instance</span> <span class="dt">Arrow</span> <span class="dt">Analysis</span> <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>  arr f <span class="ot">=</span> <span class="dt">Analysis</span> <span class="fu">mempty</span> <span class="fu">mempty</span> (<span class="fu">pure</span> <span class="op">.</span> f)</span>
<span id="cb12-3"><a href="#cb12-3"></a></span>
<span id="cb12-4"><a href="#cb12-4"></a>  first (<span class="dt">Analysis</span> find run get) <span class="ot">=</span></span>
<span id="cb12-5"><a href="#cb12-5"></a>    <span class="dt">Analysis</span> (find <span class="op">.</span> <span class="fu">fst</span>) run <span class="op">$</span> \(b, d) <span class="ot">-&gt;</span> (,d) <span class="op">&lt;$&gt;</span> get b</span>
<span id="cb12-6"><a href="#cb12-6"></a></span>
<span id="cb12-7"><a href="#cb12-7"></a><span class="kw">instance</span> <span class="dt">ArrowChoice</span> <span class="dt">Analysis</span> <span class="kw">where</span></span>
<span id="cb12-8"><a href="#cb12-8"></a>  left (<span class="dt">Analysis</span> find run get) <span class="ot">=</span> <span class="dt">Analysis</span> find&#39; run get&#39;</span>
<span id="cb12-9"><a href="#cb12-9"></a>    <span class="kw">where</span></span>
<span id="cb12-10"><a href="#cb12-10"></a>      find&#39; <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb12-11"><a href="#cb12-11"></a>        <span class="dt">Left</span> b <span class="ot">-&gt;</span> find b</span>
<span id="cb12-12"><a href="#cb12-12"></a>        <span class="dt">Right</span> d <span class="ot">-&gt;</span> <span class="fu">pure</span> ()</span>
<span id="cb12-13"><a href="#cb12-13"></a>      get&#39; <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb12-14"><a href="#cb12-14"></a>        <span class="dt">Left</span> b <span class="ot">-&gt;</span> <span class="dt">Left</span> <span class="op">&lt;$&gt;</span> get b</span>
<span id="cb12-15"><a href="#cb12-15"></a>        <span class="dt">Right</span> d <span class="ot">-&gt;</span> <span class="dt">Right</span> <span class="op">&lt;$&gt;</span> <span class="fu">pure</span> d</span></code></pre></div>
<p>Finally, armed with all these instances, it now becomes possible to write complex analyses in a data-flow style using arrow notation:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="co">-- Hypothetical example, where both an unbound variable analysis is done,</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="co">-- together with a liveness analysis, followed by a dead code analysis.</span></span>
<span id="cb13-3"><a href="#cb13-3"></a></span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="kw">data</span> <span class="dt">AST</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="kw">data</span> <span class="dt">UnboundVar</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="kw">data</span> <span class="dt">Liveness</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb13-7"><a href="#cb13-7"></a><span class="kw">data</span> <span class="dt">DeadCode</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb13-8"><a href="#cb13-8"></a></span>
<span id="cb13-9"><a href="#cb13-9"></a><span class="ot">unboundVarAnalysis ::</span> <span class="dt">Analysis</span> <span class="dt">AST</span> [<span class="dt">UnboundVar</span>]</span>
<span id="cb13-10"><a href="#cb13-10"></a><span class="ot">livenessAnalysis ::</span> <span class="dt">Analysis</span> <span class="dt">AST</span> [<span class="dt">Liveness</span>]</span>
<span id="cb13-11"><a href="#cb13-11"></a><span class="ot">deadCodeAnalysis ::</span> <span class="dt">Analysis</span> [<span class="dt">Liveness</span>] [<span class="dt">DeadCode</span>]</span>
<span id="cb13-12"><a href="#cb13-12"></a></span>
<span id="cb13-13"><a href="#cb13-13"></a><span class="ot">analysis ::</span> <span class="dt">Analysis</span> <span class="dt">AST</span> ([<span class="dt">UnboundVar</span>], [<span class="dt">DeadCode</span>])</span>
<span id="cb13-14"><a href="#cb13-14"></a>analysis <span class="ot">=</span> proc ast <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb13-15"><a href="#cb13-15"></a>  unbounds <span class="ot">&lt;-</span> unboundVarAnalysis <span class="op">-&lt;</span> ast</span>
<span id="cb13-16"><a href="#cb13-16"></a>  liveInstructions <span class="ot">&lt;-</span> livenessAnalysis <span class="op">-&lt;</span> ast</span>
<span id="cb13-17"><a href="#cb13-17"></a>  deadInstructions <span class="ot">&lt;-</span> deadCodeAnalysis <span class="op">-&lt;</span> liveInstructions</span>
<span id="cb13-18"><a href="#cb13-18"></a>  returnA <span class="op">-&lt;</span> (unbounds, deadInstructions)</span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>TODO rewrite, flow</p>
<p>In this post I explained my thought process implementing a new analysis type for the souffle-haskell library. This <code>Analysis</code> type will become available in souffle-haskell v2.3.0 (or you can already start experimenting with it by checking out <a href="https://github.com/luc-tielen/souffle-haskell">the latest commit</a>).</p>
<p>By creating a new data type encapsulating the idea, we made it first class. Additionally, by implementing some key type-class instances, it becomes possible to integrate it with the rest of the Haskell ecosysyem.</p>
<p>If you are interested in more content like this, follow me on <a href="https://twitter.com/luctielen">Twitter</a>. Feel free to contact me if you have any questions or comments about this topic.</p>
<p>TODO image using arrow to compose analyses, add snippet right before conclusion hemingway spell/grammar check</p>
    <img src="https://api.stathat.com/c?ukey=MTk2NzAgWkL6UC1F__NJ8FQSQf0CiA~~&key=27ZUKzMSpTwf7JNpDPdlHiA0WVlO&count=1"
         style="display:none;" width="1" height="1"/>
  </main>
</body>
