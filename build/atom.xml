<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>FP -&gt; Compilers -&gt; Logic -&gt; Blog</title>
    <link href="https://luctielen.com/atom.xml" rel="self" type="application/rss+xml" />
  <updated>2022-03-12T07:24:SZ</updated>
  <author>
      <name>Luc Tielen</name>
  </author>
  <id>https://luctielen.com/</id>

  <entry>
      <title>Calling Zig from Haskell</title>
      <link href="https://luctielen.com/posts/calling_zig_from_haskell"/>
      <id>https://luctielen.com/posts/calling_zig_from_haskell</id>
      <updated></updated>
      <category term="zig"/>
      <category term="haskell"/>
      <summary></summary>
      <content type="html"><![CDATA[<p>In today's article, I will show how you can interface Zig code with Haskell. Zig is a low level language that aims to be a modern replacement for C (minus all the footguns). Zig has great C interop and because of this, calling into Zig from Haskell is almost as easy as calling into C code.</p>
<h2 id="project-setup">Project setup</h2>
<p>Since our example will contain both Haskell and Zig code, we will need to setup our project for both languages. From here on, I will assume you have both <code>cabal</code> (a Haskell project/ build tool) and <code>zig</code> (the Zig compiler) installed. First, let's run some commands to initialize a Haskell project using <code>cabal</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1"></a>$ <span class="fu">mkdir</span> language-interop</span>
<span id="cb1-2"><a href="#cb1-2"></a>$ <span class="bu">cd</span> language-interop</span>
<span id="cb1-3"><a href="#cb1-3"></a>$ <span class="ex">cabal</span> init --minimal --exe</span></code></pre></div>
<p>This will generate the following directories and files:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1"></a>$ <span class="ex">tree</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="ex">.</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>â”œâ”€â”€ <span class="ex">app</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>â”‚Â Â  â””â”€â”€ <span class="ex">Main.hs</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>â”œâ”€â”€ <span class="ex">CHANGELOG.md</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>â””â”€â”€ <span class="ex">language-interop.cabal</span></span></code></pre></div>
<p>Now that we have the initial Haskell project skeleton, let's setup our Zig library called "example". We will setup our Zig project in a "cbits" folder inside the Haskell project (a convention for storing C, C++ (and Zig?) files in a Haskell project).</p>
<p>Here are the commands to setup the Zig library:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1"></a>$ <span class="fu">mkdir</span> -p cbits/example</span>
<span id="cb3-2"><a href="#cb3-2"></a>$ <span class="bu">cd</span> cbits/example</span>
<span id="cb3-3"><a href="#cb3-3"></a>$ <span class="ex">zig</span> init-lib</span></code></pre></div>
<p>We're not done yet though. We need to modify the <code>build.zig</code> file to take care of a few things:</p>
<ol>
<li>We need to link with the C library (<code>libc</code>) since we will be using the C allocator from Zig later on,</li>
<li>In debug mode: bundle the "compiler runtime" to avoid linker errors related to safety checks generated by Zig (e.g. stack protection),</li>
<li>In release mode: disable the safety checks in Zig.</li>
</ol>
<p>This is what the modified <code>build.zig</code> should look like:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode zig"><code class="sourceCode zig"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">const</span> std <span class="op">=</span> <span class="im">@import</span>(<span class="st">&quot;std&quot;</span>);</span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="cn">pub</span> <span class="cn">fn</span> build(b: <span class="op">*</span>std<span class="op">.</span>build<span class="op">.</span>Builder) <span class="dt">void</span> {</span>
<span id="cb4-4"><a href="#cb4-4"></a>    <span class="kw">const</span> mode <span class="op">=</span> b<span class="op">.</span>standardReleaseOptions();</span>
<span id="cb4-5"><a href="#cb4-5"></a></span>
<span id="cb4-6"><a href="#cb4-6"></a>    <span class="kw">const</span> lib <span class="op">=</span> b<span class="op">.</span>addStaticLibrary(<span class="st">&quot;example&quot;</span>, <span class="st">&quot;src/main.zig&quot;</span>);</span>
<span id="cb4-7"><a href="#cb4-7"></a>    lib<span class="op">.</span>setBuildMode(mode);</span>
<span id="cb4-8"><a href="#cb4-8"></a>    lib<span class="op">.</span>linkLibC();  <span class="co">// Needed for linking with libc</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>    switch (mode) {</span>
<span id="cb4-10"><a href="#cb4-10"></a>        <span class="co">// This includes the compiler runtime (Zig runtime checks):</span></span>
<span id="cb4-11"><a href="#cb4-11"></a>        <span class="op">.</span>Debug, <span class="op">.</span>ReleaseSafe <span class="op">=&gt;</span> lib<span class="op">.</span>bundle_compiler_rt <span class="op">=</span> <span class="kw">true</span>,</span>
<span id="cb4-12"><a href="#cb4-12"></a>        <span class="co">// This turns off the checks completely for release mode:</span></span>
<span id="cb4-13"><a href="#cb4-13"></a>        <span class="op">.</span>ReleaseFast, <span class="op">.</span>ReleaseSmall <span class="op">=&gt;</span> lib<span class="op">.</span>disable_stack_probing <span class="op">=</span> <span class="kw">true</span>,</span>
<span id="cb4-14"><a href="#cb4-14"></a>    }</span>
<span id="cb4-15"><a href="#cb4-15"></a>    lib<span class="op">.</span>install();</span>
<span id="cb4-16"><a href="#cb4-16"></a></span>
<span id="cb4-17"><a href="#cb4-17"></a>    <span class="kw">const</span> main_tests <span class="op">=</span> b<span class="op">.</span>addTest(<span class="st">&quot;src/main.zig&quot;</span>);</span>
<span id="cb4-18"><a href="#cb4-18"></a>    <span class="co">// Depending on how you set up your Zig code,</span></span>
<span id="cb4-19"><a href="#cb4-19"></a>    <span class="co">// you may need to link with libc in your tests as well:</span></span>
<span id="cb4-20"><a href="#cb4-20"></a>    main_tests<span class="op">.</span>linkLibC();</span>
<span id="cb4-21"><a href="#cb4-21"></a>    main_tests<span class="op">.</span>setBuildMode(mode);</span>
<span id="cb4-22"><a href="#cb4-22"></a></span>
<span id="cb4-23"><a href="#cb4-23"></a>    <span class="kw">const</span> test_step <span class="op">=</span> b<span class="op">.</span>step(<span class="st">&quot;test&quot;</span>, <span class="st">&quot;Run library tests&quot;</span>);</span>
<span id="cb4-24"><a href="#cb4-24"></a>    test_step<span class="op">.</span>dependOn(<span class="op">&amp;</span>main_tests<span class="op">.</span>step);</span>
<span id="cb4-25"><a href="#cb4-25"></a>}</span></code></pre></div>
<p>The initial configuration for Zig is finished. Confirm everything works correctly by running <code>zig build</code> in the <code>cbits/example/</code> directory. If it doesn't show any errors, then the Zig setup is finished and we can move on to the Haskell setup! For this, we need to update the cabal file to take the Zig code into account by adding the <code>extra-lib-dirs</code> and <code>extra-libraries</code> info:</p>
<pre class="cabal"><code>-- other cabal config ...

executable zig-interop
  -- executable config ...

  -- The folder where cabal will look for .a files:
  extra-lib-dirs: cbits/example/zig-out/lib/
  -- The name of the libraries we want to link with.
  -- &quot;example&quot; means we want to link with &quot;libexample.a&quot;.
  extra-libraries: example</code></pre>
<p>And we're all set! If you followed along with all the steps, your entire project structure should look as follows:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1"></a>$ <span class="ex">tree</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="ex">.</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>â”œâ”€â”€ <span class="ex">app</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>â”‚Â Â  â””â”€â”€ <span class="ex">Main.hs</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>â”œâ”€â”€ <span class="ex">cbits</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>â”‚Â Â  â””â”€â”€ <span class="ex">example</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>â”‚Â Â      â”œâ”€â”€ <span class="ex">build.zig</span></span>
<span id="cb6-8"><a href="#cb6-8"></a>â”‚Â Â      â””â”€â”€ <span class="ex">src</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>â”‚Â Â          â””â”€â”€ <span class="ex">main.zig</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>â”œâ”€â”€ <span class="ex">CHANGELOG.md</span></span>
<span id="cb6-11"><a href="#cb6-11"></a>â””â”€â”€ <span class="ex">zig-interop.cabal</span></span></code></pre></div>
<h2 id="interfacing-haskell-with-zig">Interfacing Haskell with Zig</h2>
<p>Our project is all ready, so we can start calling into Zig code! Let's start with a simple top level function <code>add</code> in <code>main.zig</code> that adds 2 numbers together:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode zig"><code class="sourceCode zig"><span id="cb7-1"><a href="#cb7-1"></a><span class="co">// Note: Export is needed to make the function available outside of Zig</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="co">// The C calling convention is used by default for exported functions,</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="co">// but it&#39;s better to be explicit about it (specified by &quot;callconv&quot;).</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="kw">export</span> <span class="cn">fn</span> add(a: <span class="dt">i32</span>, b: <span class="dt">i32</span>) <span class="kw">callconv</span>(<span class="op">.</span>C) <span class="dt">i32</span> {</span>
<span id="cb7-5"><a href="#cb7-5"></a>  <span class="kw">return</span> a <span class="op">+</span> b;</span>
<span id="cb7-6"><a href="#cb7-6"></a>}</span></code></pre></div>
<p>Before we change the Haskell code, we need to re-compile the code using <code>zig build</code> again. Quick tip: use a Makefile or a script to automate all these small steps. Once the Zig library has been built, we need to introduce a foreign import in <code>Main.hs</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a>foreign <span class="kw">import</span> ccall unsafe &quot;add&quot; foreignAdd</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="ot">  ::</span> <span class="dt">CInt</span> <span class="ot">-&gt;</span> <span class="dt">CInt</span> <span class="ot">-&gt;</span> <span class="dt">CInt</span></span></code></pre></div>
<p>This import is needed to be able to access the "add" function from Zig in Haskell as "foreignAdd". For a detailed explanation of all the keywords in the import, check out my previous blogpost on <a href="../calling_cpp_from_haskell">Calling C++ from Haskell</a>. After importing the Zig function, we can call it like any other Haskell code:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb9-2"><a href="#cb9-2"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> foreignAdd <span class="dv">3</span> <span class="dv">4</span>  <span class="co">-- prints 7 to the console</span></span></code></pre></div>
<p>This snippet prints out <code>7</code> to the console. Great! Now for something a little more complicated: managing a Zig struct from Haskell and calling it's member functions. In order to do that, we first need an example struct, so let's define one:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode zig"><code class="sourceCode zig"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">const</span> Allocator <span class="op">=</span> std<span class="op">.</span>mem<span class="op">.</span>Allocator;</span>
<span id="cb10-2"><a href="#cb10-2"></a></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="kw">const</span> Example <span class="op">=</span> <span class="kw">struct</span> {</span>
<span id="cb10-4"><a href="#cb10-4"></a>    field: <span class="dt">i32</span>,</span>
<span id="cb10-5"><a href="#cb10-5"></a></span>
<span id="cb10-6"><a href="#cb10-6"></a>    <span class="co">// Note: normally the convention to initialize a struct is:</span></span>
<span id="cb10-7"><a href="#cb10-7"></a>    <span class="co">// fn init() Example {</span></span>
<span id="cb10-8"><a href="#cb10-8"></a>    <span class="co">//     return Example{ .field = 42 };</span></span>
<span id="cb10-9"><a href="#cb10-9"></a>    <span class="co">// }</span></span>
<span id="cb10-10"><a href="#cb10-10"></a>    <span class="co">//</span></span>
<span id="cb10-11"><a href="#cb10-11"></a>    <span class="co">// This change is done so we can use any allocator (C allocator</span></span>
<span id="cb10-12"><a href="#cb10-12"></a>    <span class="co">// in actual code, and the testing allocator in test code) to</span></span>
<span id="cb10-13"><a href="#cb10-13"></a>    <span class="co">// allocate memory for our struct.</span></span>
<span id="cb10-14"><a href="#cb10-14"></a>    <span class="cn">fn</span> create(allocator: Allocator) <span class="op">*</span>Example {</span>
<span id="cb10-15"><a href="#cb10-15"></a>        <span class="co">// If we fail to allocate, there is no good way to recover</span></span>
<span id="cb10-16"><a href="#cb10-16"></a>        <span class="co">// in this case, so we error with a panic.</span></span>
<span id="cb10-17"><a href="#cb10-17"></a>        <span class="kw">const</span> obj <span class="op">=</span> allocator<span class="op">.</span>create(Example)</span>
<span id="cb10-18"><a href="#cb10-18"></a>          catch std<span class="op">.</span>debug<span class="op">.</span>panic(<span class="st">&quot;Failed to allocate Example struct&quot;</span>, <span class="op">.</span>{});</span>
<span id="cb10-19"><a href="#cb10-19"></a>        obj<span class="op">.</span>field <span class="op">=</span> <span class="dv">42</span>;</span>
<span id="cb10-20"><a href="#cb10-20"></a>        <span class="kw">return</span> obj;</span>
<span id="cb10-21"><a href="#cb10-21"></a>    }</span>
<span id="cb10-22"><a href="#cb10-22"></a></span>
<span id="cb10-23"><a href="#cb10-23"></a>    <span class="cn">fn</span> deinit(self: <span class="op">*</span>Example) <span class="dt">void</span> {</span>
<span id="cb10-24"><a href="#cb10-24"></a>        <span class="co">// No de-initialization needed for this simple struct</span></span>
<span id="cb10-25"><a href="#cb10-25"></a>        <span class="cn">_</span> <span class="op">=</span> self;</span>
<span id="cb10-26"><a href="#cb10-26"></a>    }</span>
<span id="cb10-27"><a href="#cb10-27"></a></span>
<span id="cb10-28"><a href="#cb10-28"></a>    <span class="cn">fn</span> do_stuff(self: <span class="op">*</span>Example, arg: <span class="dt">i32</span>) <span class="dt">bool</span> {</span>
<span id="cb10-29"><a href="#cb10-29"></a>        <span class="kw">return</span> self<span class="op">.</span>field <span class="op">==</span> arg;</span>
<span id="cb10-30"><a href="#cb10-30"></a>    }</span>
<span id="cb10-31"><a href="#cb10-31"></a>};</span></code></pre></div>
<p>The final thing we need to do on the Zig side is to write some free functions that wrap the functionality of the struct. The exported functions form the API that the Haskell code will call into:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode zig"><code class="sourceCode zig"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">export</span> <span class="cn">fn</span> example_create() <span class="kw">callconv</span>(<span class="op">.</span>C) <span class="op">*</span>Example {</span>
<span id="cb11-2"><a href="#cb11-2"></a>    <span class="kw">return</span> Example<span class="op">.</span>create(std<span class="op">.</span>heap<span class="op">.</span>c_allocator);</span>
<span id="cb11-3"><a href="#cb11-3"></a>}</span>
<span id="cb11-4"><a href="#cb11-4"></a></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="kw">export</span> <span class="cn">fn</span> example_destroy(ptr: <span class="op">?*</span>Example) <span class="kw">callconv</span>(<span class="op">.</span>C) <span class="dt">void</span> {</span>
<span id="cb11-6"><a href="#cb11-6"></a>    std<span class="op">.</span>debug<span class="op">.</span>assert(ptr !<span class="op">=</span> <span class="kw">null</span>);</span>
<span id="cb11-7"><a href="#cb11-7"></a></span>
<span id="cb11-8"><a href="#cb11-8"></a>    <span class="kw">const</span> obj <span class="op">=</span> ptr<span class="op">.?</span>;</span>
<span id="cb11-9"><a href="#cb11-9"></a>    obj<span class="op">.</span>deinit();</span>
<span id="cb11-10"><a href="#cb11-10"></a>    std<span class="op">.</span>heap<span class="op">.</span>c_allocator<span class="op">.</span>destroy(obj);</span>
<span id="cb11-11"><a href="#cb11-11"></a>}</span>
<span id="cb11-12"><a href="#cb11-12"></a></span>
<span id="cb11-13"><a href="#cb11-13"></a><span class="kw">export</span> <span class="cn">fn</span> example_do_stuff(ptr: <span class="op">?*</span>Example, arg: <span class="dt">i32</span>) <span class="kw">callconv</span>(<span class="op">.</span>C) <span class="dt">bool</span> {</span>
<span id="cb11-14"><a href="#cb11-14"></a>    std<span class="op">.</span>debug<span class="op">.</span>assert(ptr !<span class="op">=</span> <span class="kw">null</span>);</span>
<span id="cb11-15"><a href="#cb11-15"></a></span>
<span id="cb11-16"><a href="#cb11-16"></a>    <span class="kw">return</span> ptr<span class="op">.?.</span>do_stuff(arg);</span>
<span id="cb11-17"><a href="#cb11-17"></a>}</span></code></pre></div>
<p>In the snippet above we have one function for each of the struct functions. Note that <code>example_destroy</code> and <code>example_do_stuff</code> take an optional pointer to the struct, since the Haskell code is in control of calling these functions and could pass in <em>any</em> pointer (that could be <code>null</code>).</p>
<p>Since the allocator is passed to the <code>Example.create</code> function (a common pattern in Zig), this gives us flexibility regarding memory allocations. Here, the exported functions make use of the <code>std.heap.c_allocator</code> which is a fast allocator that uses the <code>malloc</code> and <code>free</code> functions from <code>libc</code> under the hood. At the same time, this setup allows writing Zig unit tests that use the testing allocator to check for potential memory leaks.</p>
<p>Now it's time to bind to our Zig struct from Haskell:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a>foreign <span class="kw">import</span> ccall &quot;example_create&quot; createExample</span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="ot">  ::</span> <span class="dt">IO</span> (<span class="dt">Ptr</span> <span class="dt">Example</span>)</span>
<span id="cb12-3"><a href="#cb12-3"></a>foreign <span class="kw">import</span> ccall &quot;&amp;example_destroy&quot; destroyExample</span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="ot">  ::</span> <span class="dt">FunPtr</span> (<span class="dt">Ptr</span> <span class="dt">Example</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ())</span>
<span id="cb12-5"><a href="#cb12-5"></a>foreign <span class="kw">import</span> ccall &quot;example_do_stuff&quot; doStuffExample</span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="ot">  ::</span> <span class="dt">Ptr</span> <span class="dt">Example</span> <span class="ot">-&gt;</span> <span class="dt">CInt</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">CBool</span></span>
<span id="cb12-7"><a href="#cb12-7"></a></span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="kw">data</span> <span class="dt">Example</span></span>
<span id="cb12-9"><a href="#cb12-9"></a></span>
<span id="cb12-10"><a href="#cb12-10"></a><span class="ot">mkExample ::</span> <span class="dt">IO</span> (<span class="dt">ForeignPtr</span> <span class="dt">Example</span>)</span>
<span id="cb12-11"><a href="#cb12-11"></a>mkExample <span class="ot">=</span> mask_ <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb12-12"><a href="#cb12-12"></a>  <span class="co">-- NOTE: mask_ is needed to avoid leaking memory between</span></span>
<span id="cb12-13"><a href="#cb12-13"></a>  <span class="co">-- allocating the struct and wrapping the `Ptr` in a `ForeignPtr`.</span></span>
<span id="cb12-14"><a href="#cb12-14"></a>  ptr <span class="ot">&lt;-</span> createExample</span>
<span id="cb12-15"><a href="#cb12-15"></a>  newForeignPtr destroyExample ptr</span>
<span id="cb12-16"><a href="#cb12-16"></a></span>
<span id="cb12-17"><a href="#cb12-17"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb12-18"><a href="#cb12-18"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-19"><a href="#cb12-19"></a>  ptr <span class="ot">&lt;-</span> mkExample</span>
<span id="cb12-20"><a href="#cb12-20"></a>  withForeignPtr ptr <span class="op">$</span> \p <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-21"><a href="#cb12-21"></a>    result <span class="ot">&lt;-</span> doStuffExample p <span class="dv">10</span></span>
<span id="cb12-22"><a href="#cb12-22"></a>    <span class="fu">print</span> result</span></code></pre></div>
<p>On the Haskell side, we need to create an empty datatype <code>Example</code>, that is used as a type-level tag for keeping track of the type a pointer is pointing to. This ensures at compile time that pointers of different types do not get mixed up (that could potentially lead to really weird and hard to find bugs).</p>
<p>In Haskell, we don't have <code>defer</code> like in Zig to automatically cleanup memory that is no longer needed, but instead it provides a <code>ForeignPtr</code> type that automatically frees a pointer when it is no longer referenced. For each of the imported function calls to Zig we need to use <code>withForeignPtr</code> to get access to the underlying pointer (the <code>Ptr</code> type). Finally, once we have access to the <code>Ptr</code>, we can call the Zig code like any other function in Haskell.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this post I showed how it is possible to interface Zig with Haskell. Integrating the two languages with each other is not that much harder compared to calling C from Haskell thanks to the great language interop support provided by Zig.</p>
<p>One thing to mention is that this approach isn't specific to Haskell, you would only need to swap out the Haskell code with your language of choice to bind to the underlying Zig code.</p>
<p>If you have any questions or thoughts about this article, let me know on <a href="https://twitter.com/luctielen">Twitter</a>. If you want to play around with the code from this post, it can be found <a href="https://github.com/luc-tielen/playground/tree/calling-zig-from-haskell">here</a>.</p>]]></content>
  </entry>
  <entry>
      <title>Analyses are arrows</title>
      <link href="https://luctielen.com/posts/analyses_are_arrows"/>
      <id>https://luctielen.com/posts/analyses_are_arrows</id>
      <updated></updated>
      <category term="haskell"/>
      <summary></summary>
      <content type="html"><![CDATA[<p>In today's post, I explore how we can use Haskell to compose multiple SoufflÃ© Datalog analyses in an elegant and principled way using various Haskell type-classes. No deep knowledge of SoufflÃ© Datalog or the <a href="https://github.com/luc-tielen/souffle-haskell">souffle-haskell library</a> is expected, but I do expect some familiarity with the more often used type-classes (Functor, Applicative, ...).</p>
<h2 id="the-analysis-data-type">The Analysis data type</h2>
<p>As a quick recap, the souffle-haskell library provides bindings for interacting with SoufflÃ© Datalog. All functionality is provided via a <code>SouffleM</code> monad, which focuses on a single Datalog analysis / program. Like I mentioned in my <a href="../static_analysis_using_haskell_and_datalog/">blogpost about "Static analysis using Haskell and Datalog"</a>, an analysis consists of a few distinct parts:</p>
<ol>
<li>Find all relevant facts related to our Datalog analyses (in Haskell),</li>
<li>Explicitly "run" SoufflÃ© to compute all derived facts,</li>
<li>Collect all results back on the Haskell side.</li>
</ol>
<p>We can make this idea first-class by turning this into a Haskell datatype, giving us the following:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="co">-- NOTE: &quot;Handle prog&quot; is a type-safe handle of a Datalog program</span></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">data</span> <span class="dt">Analysis</span> prog input output</span>
<span id="cb1-4"><a href="#cb1-4"></a>  <span class="ot">=</span> <span class="dt">Analysis</span> (<span class="dt">Handle</span> prog <span class="ot">-&gt;</span> input <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> ())  <span class="co">-- finding facts</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>             (<span class="dt">Handle</span> prog <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> ())           <span class="co">-- running SoufflÃ©</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>             (<span class="dt">Handle</span> prog <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> output)       <span class="co">-- retrieving results</span></span></code></pre></div>
<p>Now that we have this new type, let's try writing some instances for it. First of, let's start with the <code>Functor</code> instance. This will make it possible to transform the result of an analysis:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Analysis</span> prog input) <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>  <span class="fu">fmap</span> f (<span class="dt">Analysis</span> find run get) <span class="ot">=</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    <span class="dt">Analysis</span> find run (<span class="fu">fmap</span> (<span class="fu">fmap</span> f) get)</span></code></pre></div>
<p>Besides <code>Functor</code>, we can also implement <code>Profunctor</code>. This gives us the ability to transform the input type of an analysis (using <code>lmap</code>):</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">instance</span> <span class="dt">Profunctor</span> (<span class="dt">Analysis</span> prog) <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>  lmap f (<span class="dt">Analysis</span> find run get) <span class="ot">=</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="dt">Analysis</span> (\h <span class="ot">-&gt;</span> lmap f (find h)) run get</span>
<span id="cb3-4"><a href="#cb3-4"></a></span>
<span id="cb3-5"><a href="#cb3-5"></a>  rmap <span class="ot">=</span> <span class="fu">fmap</span></span></code></pre></div>
<p><code>Semigroup</code> and <code>Monoid</code> instances are also possible, but they don't provide much additional value on top of what souffle-haskell already provides with the <code>SouffleM</code> monad. I chose to provide them anyway, because maybe somebody else has a good usecase for it (and the instances are straight-forward anyway) <span class="emoji" data-emoji="wink">ðŸ˜‰</span>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">instance</span> <span class="dt">Semigroup</span> output <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">Analysis</span> prog input output) <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>  <span class="dt">Analysis</span> find1 run1 get1 <span class="op">&lt;&gt;</span> <span class="dt">Analysis</span> find2 run2 get2 <span class="ot">=</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="dt">Analysis</span> (find1 <span class="op">&lt;&gt;</span> find2) (run1 <span class="op">&lt;&gt;</span> run2) (get1 <span class="op">&lt;&gt;</span> get2)</span>
<span id="cb4-4"><a href="#cb4-4"></a></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="kw">instance</span> <span class="dt">Monoid</span> output <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Analysis</span> prog input output) <span class="kw">where</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">Analysis</span> <span class="fu">mempty</span> <span class="fu">mempty</span> <span class="fu">mempty</span></span></code></pre></div>
<p>Next up is <code>Applicative</code>. Implementing this for our <code>Analysis</code> type enables us to combine two different analyses from multiple Datalog programs with the same input type using applicative-style programming. We can try creating an instance for this type-class, but we would hit a snag when we try to use it. To find out why, take a look at the <code>(&lt;*&gt;)</code>-operator, specialized for our analysis type:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="ot">(&lt;*&gt;) ::</span> <span class="dt">Analysis</span> prog input (a <span class="ot">-&gt;</span> b)</span>
<span id="cb5-2"><a href="#cb5-2"></a>      <span class="ot">-&gt;</span> <span class="dt">Analysis</span> prog input  a</span>
<span id="cb5-3"><a href="#cb5-3"></a>      <span class="ot">-&gt;</span> <span class="dt">Analysis</span> prog input  b</span></code></pre></div>
<p>It may not be immediately obvious, but the <code>prog</code> type-variable has to be the same for both arguments passed to the operator! If you recall, this type-variable is used by the Handle type to keep track of the Datalog program it belongs to. Because the type-variable needs to stay the same for both arguments, we can't compose 2 different Datalog programs like this. We also can't get rid of this phantom type-variable, because this is what makes it possible for souffle-haskell to perform many compile-time checks as I explained in my post about <a href="../supercharge_your_handles_with_phantom_types">supercharging handles with phantom types</a>.</p>
<p>Luckily, we can circumvent this issue using a trick functional programmers often use: partial application. The trick is to close over the handle, so it no longer appears in our <code>Analysis</code> type, effectively hiding the type-variable. We can do this as follows:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="co">-- No more &#39;prog&#39; type variable!</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="kw">data</span> <span class="dt">Analysis</span> input output</span>
<span id="cb6-3"><a href="#cb6-3"></a>  <span class="ot">=</span> <span class="dt">Analysis</span> (input <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> ())</span>
<span id="cb6-4"><a href="#cb6-4"></a>             (<span class="dt">SouffleM</span> ())</span>
<span id="cb6-5"><a href="#cb6-5"></a>             (<span class="dt">SouffleM</span> output)</span>
<span id="cb6-6"><a href="#cb6-6"></a></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="co">-- An example that shows how to close over a handle in an Analysis:</span></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="ot">example ::</span> <span class="dt">Handle</span> prog <span class="ot">-&gt;</span> <span class="dt">Analysis</span> [<span class="dt">Edge</span>] [<span class="dt">Reachable</span>]</span>
<span id="cb6-9"><a href="#cb6-9"></a>example h <span class="ot">=</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>  <span class="dt">Analysis</span> (Souffle.addFacts h)</span>
<span id="cb6-11"><a href="#cb6-11"></a>           (Souffle.run h)</span>
<span id="cb6-12"><a href="#cb6-12"></a>           (Souffle.getFacts h)</span></code></pre></div>
<p>With this change we need to reimplement our previously defined instances though. By applying hole driven development, we quickly find the following implementations:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Analysis</span> input) <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>  <span class="fu">fmap</span> f (<span class="dt">Analysis</span> find run get) <span class="ot">=</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>    <span class="dt">Analysis</span> find run (<span class="fu">fmap</span> f get)</span>
<span id="cb7-4"><a href="#cb7-4"></a></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="kw">instance</span> <span class="dt">Profunctor</span> <span class="dt">Analysis</span> <span class="kw">where</span></span>
<span id="cb7-6"><a href="#cb7-6"></a>  lmap f (<span class="dt">Analysis</span> find run get) <span class="ot">=</span></span>
<span id="cb7-7"><a href="#cb7-7"></a>    <span class="dt">Analysis</span> (lmap f find) run get</span>
<span id="cb7-8"><a href="#cb7-8"></a></span>
<span id="cb7-9"><a href="#cb7-9"></a>  rmap <span class="ot">=</span> <span class="fu">fmap</span></span>
<span id="cb7-10"><a href="#cb7-10"></a></span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="co">-- NOTE: omitting Semigroup and Monoid, these have exactly</span></span>
<span id="cb7-12"><a href="#cb7-12"></a><span class="co">-- the same implementations as before.</span></span></code></pre></div>
<p>Now we can also implement <code>Applicative</code> without the composition issue mentioned earlier:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Analysis</span> input) <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>  <span class="fu">pure</span> a <span class="ot">=</span> <span class="dt">Analysis</span> <span class="fu">mempty</span> <span class="fu">mempty</span> (<span class="fu">pure</span> a)</span>
<span id="cb8-3"><a href="#cb8-3"></a></span>
<span id="cb8-4"><a href="#cb8-4"></a>  <span class="dt">Analysis</span> find1 run1 get1 <span class="op">&lt;*&gt;</span> <span class="dt">Analysis</span> find2 run2 get2 <span class="ot">=</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>    <span class="dt">Analysis</span> (find1 <span class="op">&lt;&gt;</span> find2) (run1 <span class="op">&lt;&gt;</span> run2) (get1 <span class="op">&lt;*&gt;</span> get2)</span></code></pre></div>
<p>As a quick side note, the behavior of this instance is very similar to what I described in my post about <a href="../combining_folds_using_semigroups">combining folds with semigroups</a>. For example, with a library like <a href="https://hackage.haskell.org/package/recursion-schemes">recursion-schemes</a>, a single fold can be performed to find all facts for multiple analyses.</p>
<h2 id="additional-forms-of-composition">Additional forms of composition</h2>
<p>We already achieved quite a bit so far with these first instances, but can we go further? One example that comes to mind is sequential composition. If we can think of a function where the output of one analysis forms the input of another, then it should be possible to execute them one after the other:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="ot">(?) ::</span> <span class="dt">Analysis</span> a b <span class="ot">-&gt;</span> <span class="dt">Analysis</span> b c <span class="ot">-&gt;</span> <span class="dt">Analysis</span> a c</span></code></pre></div>
<p>After some searching, this is the (flipped) <code>(.)</code>-operator (from <a href="">Control.Category</a>). However, if we try to implement <code>Category</code> for our analysis type, we run into an issue yet again. This time the issue is with the <code>id :: Analysis a a</code> "constant": for the third argument of the constructor, we can't construct a value of type <code>a</code> out of thin air!</p>
<p>All hope is not lost though. Just like before, we can do a small adjustment to our type (at the cost of rewriting the earlier defined instances all over again):</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">data</span> <span class="dt">Analysis</span> input output</span>
<span id="cb10-2"><a href="#cb10-2"></a>  <span class="ot">=</span> <span class="dt">Analysis</span> (input <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> ())</span>
<span id="cb10-3"><a href="#cb10-3"></a>             (<span class="dt">SouffleM</span> ())</span>
<span id="cb10-4"><a href="#cb10-4"></a>             (input <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> output)  <span class="co">-- input now also passed in here</span></span>
<span id="cb10-5"><a href="#cb10-5"></a></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="co">-- Helper function, results in same behavior as before.</span></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="ot">mkAnalysis ::</span> (input <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> ())</span>
<span id="cb10-8"><a href="#cb10-8"></a>           <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> ()</span>
<span id="cb10-9"><a href="#cb10-9"></a>           <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> output</span>
<span id="cb10-10"><a href="#cb10-10"></a>           <span class="ot">-&gt;</span> <span class="dt">Analysis</span> input output</span>
<span id="cb10-11"><a href="#cb10-11"></a>mkAnalysis find run get <span class="ot">=</span> <span class="dt">Analysis</span> find run (<span class="fu">const</span> get)</span>
<span id="cb10-12"><a href="#cb10-12"></a></span>
<span id="cb10-13"><a href="#cb10-13"></a><span class="co">-- The following instances are a good exercise for</span></span>
<span id="cb10-14"><a href="#cb10-14"></a><span class="co">-- honing your hole driven development skills:</span></span>
<span id="cb10-15"><a href="#cb10-15"></a></span>
<span id="cb10-16"><a href="#cb10-16"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Analysis</span> input) <span class="kw">where</span></span>
<span id="cb10-17"><a href="#cb10-17"></a>  <span class="fu">fmap</span> f (<span class="dt">Analysis</span> find run get) <span class="ot">=</span></span>
<span id="cb10-18"><a href="#cb10-18"></a>    <span class="dt">Analysis</span> find run (<span class="fu">fmap</span> (<span class="fu">fmap</span> f) get)</span>
<span id="cb10-19"><a href="#cb10-19"></a></span>
<span id="cb10-20"><a href="#cb10-20"></a><span class="kw">instance</span> <span class="dt">Profunctor</span> <span class="dt">Analysis</span> <span class="kw">where</span></span>
<span id="cb10-21"><a href="#cb10-21"></a>  lmap f (<span class="dt">Analysis</span> find run get) <span class="ot">=</span></span>
<span id="cb10-22"><a href="#cb10-22"></a>    <span class="dt">Analysis</span> (lmap f find) run (lmap f get)</span>
<span id="cb10-23"><a href="#cb10-23"></a></span>
<span id="cb10-24"><a href="#cb10-24"></a>  rmap <span class="ot">=</span> <span class="fu">fmap</span></span>
<span id="cb10-25"><a href="#cb10-25"></a></span>
<span id="cb10-26"><a href="#cb10-26"></a><span class="kw">instance</span> <span class="dt">Semigroup</span> output <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">Analysis</span> input output) <span class="kw">where</span></span>
<span id="cb10-27"><a href="#cb10-27"></a>  <span class="dt">Analysis</span> find1 run1 get1 <span class="op">&lt;&gt;</span> <span class="dt">Analysis</span> find2 run2 get2 <span class="ot">=</span></span>
<span id="cb10-28"><a href="#cb10-28"></a>    <span class="dt">Analysis</span> (find1 <span class="op">&lt;&gt;</span> find2) (run1 <span class="op">&lt;&gt;</span> run2) (get1 <span class="op">&lt;&gt;</span> get2)</span>
<span id="cb10-29"><a href="#cb10-29"></a></span>
<span id="cb10-30"><a href="#cb10-30"></a><span class="kw">instance</span> <span class="dt">Monoid</span> output <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Analysis</span> input output) <span class="kw">where</span></span>
<span id="cb10-31"><a href="#cb10-31"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">Analysis</span> <span class="fu">mempty</span> <span class="fu">mempty</span> <span class="fu">mempty</span></span>
<span id="cb10-32"><a href="#cb10-32"></a></span>
<span id="cb10-33"><a href="#cb10-33"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Analysis</span> input) <span class="kw">where</span></span>
<span id="cb10-34"><a href="#cb10-34"></a>  <span class="fu">pure</span> a <span class="ot">=</span> <span class="dt">Analysis</span> <span class="fu">mempty</span> <span class="fu">mempty</span> (<span class="fu">const</span> <span class="op">$</span> <span class="fu">pure</span> a)</span>
<span id="cb10-35"><a href="#cb10-35"></a></span>
<span id="cb10-36"><a href="#cb10-36"></a>  <span class="dt">Analysis</span> find1 run1 get1 <span class="op">&lt;*&gt;</span> <span class="dt">Analysis</span> find2 run2 get2 <span class="ot">=</span></span>
<span id="cb10-37"><a href="#cb10-37"></a>    <span class="dt">Analysis</span> (find1 <span class="op">&lt;&gt;</span> find2)</span>
<span id="cb10-38"><a href="#cb10-38"></a>             (run1 <span class="op">&lt;&gt;</span> run2)</span>
<span id="cb10-39"><a href="#cb10-39"></a>             (\input <span class="ot">-&gt;</span> get1 input <span class="op">&lt;*&gt;</span> get2 input)</span></code></pre></div>
<p>With this change, we can now implement <code>Category</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="co">-- NOTE: this function proves it is an isomorphism with `Kleisli SouffleM`</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="ot">execAnalysis ::</span> <span class="dt">Analysis</span> input output</span>
<span id="cb11-3"><a href="#cb11-3"></a>             <span class="ot">-&gt;</span> (input <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> output)</span>
<span id="cb11-4"><a href="#cb11-4"></a>execAnalysis (<span class="dt">Analysis</span> find run get) input <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-5"><a href="#cb11-5"></a>  find input</span>
<span id="cb11-6"><a href="#cb11-6"></a>  run</span>
<span id="cb11-7"><a href="#cb11-7"></a>  get input</span>
<span id="cb11-8"><a href="#cb11-8"></a></span>
<span id="cb11-9"><a href="#cb11-9"></a><span class="kw">instance</span> <span class="dt">Category</span> <span class="dt">Analysis</span> <span class="kw">where</span></span>
<span id="cb11-10"><a href="#cb11-10"></a>  <span class="fu">id</span> <span class="ot">=</span> <span class="dt">Analysis</span> <span class="fu">mempty</span> <span class="fu">mempty</span> <span class="fu">pure</span></span>
<span id="cb11-11"><a href="#cb11-11"></a></span>
<span id="cb11-12"><a href="#cb11-12"></a>  <span class="co">-- remember: right-to-left composition!</span></span>
<span id="cb11-13"><a href="#cb11-13"></a>  <span class="dt">Analysis</span> find2 run2 get2 <span class="op">.</span> <span class="dt">Analysis</span> find1 run1 get1 <span class="ot">=</span></span>
<span id="cb11-14"><a href="#cb11-14"></a>    <span class="dt">Analysis</span> find run2 get</span>
<span id="cb11-15"><a href="#cb11-15"></a>    <span class="kw">where</span></span>
<span id="cb11-16"><a href="#cb11-16"></a>      find <span class="ot">=</span> execAnalysis (<span class="dt">Analysis</span> find1 run1 get1) <span class="op">&gt;=&gt;</span> find2</span>
<span id="cb11-17"><a href="#cb11-17"></a>      get <span class="ot">=</span> get1 <span class="op">&gt;=&gt;</span> get2</span></code></pre></div>
<p>The <code>(.)</code>-operator is a little tricky to implement: we first have to make sure the first analysis has fully executed (all 3 parts), and only then can we start the second analysis. The fetching of results now also requires calling both <code>get1</code> and <code>get2</code>, but since we are using <code>const</code> in the <code>mkAnalysis</code> helper function, a second additional fetching of results (from <code>get1</code>) is skipped thanks to Haskell's built-in laziness.</p>
<p>This new definition of the <code>Analysis</code> type also makes it possible to implement <code>Arrow</code> and <code>ArrowChoice</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">instance</span> <span class="dt">Arrow</span> <span class="dt">Analysis</span> <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>  arr f <span class="ot">=</span> <span class="dt">Analysis</span> <span class="fu">mempty</span> <span class="fu">mempty</span> (<span class="fu">pure</span> <span class="op">.</span> f)</span>
<span id="cb12-3"><a href="#cb12-3"></a></span>
<span id="cb12-4"><a href="#cb12-4"></a>  first (<span class="dt">Analysis</span> find run get) <span class="ot">=</span></span>
<span id="cb12-5"><a href="#cb12-5"></a>    <span class="dt">Analysis</span> (find <span class="op">.</span> <span class="fu">fst</span>) run <span class="op">$</span> \(b, d) <span class="ot">-&gt;</span> (,d) <span class="op">&lt;$&gt;</span> get b</span>
<span id="cb12-6"><a href="#cb12-6"></a></span>
<span id="cb12-7"><a href="#cb12-7"></a><span class="kw">instance</span> <span class="dt">ArrowChoice</span> <span class="dt">Analysis</span> <span class="kw">where</span></span>
<span id="cb12-8"><a href="#cb12-8"></a>  left (<span class="dt">Analysis</span> find run get) <span class="ot">=</span> <span class="dt">Analysis</span> find&#39; run get&#39;</span>
<span id="cb12-9"><a href="#cb12-9"></a>    <span class="kw">where</span></span>
<span id="cb12-10"><a href="#cb12-10"></a>      find&#39; <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb12-11"><a href="#cb12-11"></a>        <span class="dt">Left</span> b <span class="ot">-&gt;</span> find b</span>
<span id="cb12-12"><a href="#cb12-12"></a>        <span class="dt">Right</span> d <span class="ot">-&gt;</span> <span class="fu">pure</span> ()</span>
<span id="cb12-13"><a href="#cb12-13"></a>      get&#39; <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb12-14"><a href="#cb12-14"></a>        <span class="dt">Left</span> b <span class="ot">-&gt;</span> <span class="dt">Left</span> <span class="op">&lt;$&gt;</span> get b</span>
<span id="cb12-15"><a href="#cb12-15"></a>        <span class="dt">Right</span> d <span class="ot">-&gt;</span> <span class="dt">Right</span> <span class="op">&lt;$&gt;</span> <span class="fu">pure</span> d</span></code></pre></div>
<p>Finally, armed with all these instances, it now becomes possible to write complex analyses in a data-flow style using arrow notation:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="co">-- Hypothetical example, where both an unbound variable analysis is done,</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="co">-- together with a liveness analysis, followed by a dead code analysis.</span></span>
<span id="cb13-3"><a href="#cb13-3"></a></span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="kw">data</span> <span class="dt">AST</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="kw">data</span> <span class="dt">UnboundVar</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="kw">data</span> <span class="dt">Liveness</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb13-7"><a href="#cb13-7"></a><span class="kw">data</span> <span class="dt">DeadCode</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb13-8"><a href="#cb13-8"></a></span>
<span id="cb13-9"><a href="#cb13-9"></a><span class="ot">unboundVarAnalysis ::</span> <span class="dt">Analysis</span> <span class="dt">AST</span> [<span class="dt">UnboundVar</span>]</span>
<span id="cb13-10"><a href="#cb13-10"></a><span class="ot">livenessAnalysis ::</span> <span class="dt">Analysis</span> <span class="dt">AST</span> [<span class="dt">Liveness</span>]</span>
<span id="cb13-11"><a href="#cb13-11"></a><span class="ot">deadCodeAnalysis ::</span> <span class="dt">Analysis</span> [<span class="dt">Liveness</span>] [<span class="dt">DeadCode</span>]</span>
<span id="cb13-12"><a href="#cb13-12"></a></span>
<span id="cb13-13"><a href="#cb13-13"></a><span class="ot">analysis ::</span> <span class="dt">Analysis</span> <span class="dt">AST</span> ([<span class="dt">UnboundVar</span>], [<span class="dt">DeadCode</span>])</span>
<span id="cb13-14"><a href="#cb13-14"></a>analysis <span class="ot">=</span> proc ast <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb13-15"><a href="#cb13-15"></a>  unbounds <span class="ot">&lt;-</span> unboundVarAnalysis <span class="op">-&lt;</span> ast</span>
<span id="cb13-16"><a href="#cb13-16"></a>  liveInstructions <span class="ot">&lt;-</span> livenessAnalysis <span class="op">-&lt;</span> ast</span>
<span id="cb13-17"><a href="#cb13-17"></a>  deadInstructions <span class="ot">&lt;-</span> deadCodeAnalysis <span class="op">-&lt;</span> liveInstructions</span>
<span id="cb13-18"><a href="#cb13-18"></a>  returnA <span class="op">-&lt;</span> (unbounds, deadInstructions)</span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>In this post I explained my thought process implementing a new analysis type for the souffle-haskell library. By creating a new data type encapsulating the concept of an analysis and by implementing some key type-class instances, it integrates well with the rest of the Haskell ecosystem. This <code>Analysis</code> type will become available in souffle-haskell v2.3.0 (or you can already start experimenting with it by checking out <a href="https://github.com/luc-tielen/souffle-haskell">the latest commit</a>).</p>
<p>If you are interested in more content like this, follow me on <a href="https://twitter.com/luctielen">Twitter</a>. Feel free to contact me if you have any questions or comments about this topic.</p>]]></content>
  </entry>
  <entry>
      <title>Write your GDB scripts in Haskell</title>
      <link href="https://luctielen.com/posts/write_your_gdb_scripts_in_haskell"/>
      <id>https://luctielen.com/posts/write_your_gdb_scripts_in_haskell</id>
      <updated></updated>
      <category term="c++"/>
      <category term="debugging"/>
      <category term="haskell"/>
      <summary></summary>
      <content type="html"><![CDATA[<p>In this post, I will show how you can use the new <a href="https://github.com/luc-tielen/debugger-hs.git">debugger-hs</a> library in Haskell to generate GDB scripts.</p>
<h2 id="debugging-in-gdb">Debugging in GDB</h2>
<p>Recently, I had to do lots of debugging in a C++ codebase using GDB at $DAY_JOB. While it is possible to start debugging by placing some breakpoints yourself for simple pieces of code, this quickly turns into a lot of manual and repetitive work for complex debugging sessions.</p>
<p>Thankfully, GDB allows you to script all these actions. A GDB script is a list of statements, and is executed from top to bottom. Here's an example of such script:</p>
<pre class="gdb"><code># This sets a breakpoint at line 8 in main.cpp
break main.cpp:8

# Breakpoints are numbered, starting from 1
# We can attach automatic actions to a breakpoint using &quot;command&quot; statement:
command 1
  # The next line prints the current value of the &quot;x&quot; variable
  print x
  # And then continue the program like normal (until next breakpoint)
  continue
end</code></pre>
<p>If we run this script on the following C++ code, it would print out all values of x that are passed into the function <code>f</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1"></a><span class="dt">void</span> f(<span class="dt">int</span> x) {</span>
<span id="cb2-2"><a href="#cb2-2"></a>  <span class="co">// ...</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>}</span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>** argv) {</span>
<span id="cb2-6"><a href="#cb2-6"></a>  <span class="cf">for</span> (<span class="dt">int</span> x = <span class="dv">0</span>; x &lt; <span class="dv">100</span>; ++x) {</span>
<span id="cb2-7"><a href="#cb2-7"></a>    <span class="cf">if</span> (x % <span class="dv">10</span> == <span class="dv">0</span>) {</span>
<span id="cb2-8"><a href="#cb2-8"></a>      f(x);</span>
<span id="cb2-9"><a href="#cb2-9"></a>    }</span>
<span id="cb2-10"><a href="#cb2-10"></a>  }</span>
<span id="cb2-11"><a href="#cb2-11"></a>  <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb2-12"><a href="#cb2-12"></a>}</span></code></pre></div>
<h2 id="debugging-using-haskell">Debugging using Haskell</h2>
<p>GDB scripts already are a big improvement over manually typing in commands each time, but I still felt many things to be less than ideal:</p>
<ol>
<li>The scripting language in GDB doesn't always work as expected. For example, some GDB commands that normally print information to the screen do not print a value inside a user-defined function!</li>
<li>Setting breakpoints and handling them is a 2-step process.</li>
<li>There is no typesystem like in Haskell, issues in scripts are detected only when the line in the script is triggered. The resulting errors can also be <em>very</em> confusing.</li>
</ol>
<p>Instead of trying to keep track of all these oddities, I set out to write a library that tackles these issues. Here's what the same GDB script from before looks like using <code>debugger-hs</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">-- GDB scripts are constructed using a builder-pattern</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="ot">script ::</span> <span class="dt">Builder</span> ()</span>
<span id="cb3-3"><a href="#cb3-3"></a>script <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>  <span class="co">-- Setting a breakpoint returns the corresponding breakpoint id</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>  bp <span class="ot">&lt;-</span> <span class="fu">break</span> (<span class="dt">File</span> <span class="st">&quot;main.cpp&quot;</span> <span class="dv">8</span>)</span>
<span id="cb3-6"><a href="#cb3-6"></a></span>
<span id="cb3-7"><a href="#cb3-7"></a>  command bp <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>    <span class="fu">print</span> <span class="st">&quot;x&quot;</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>    continue</span>
<span id="cb3-10"><a href="#cb3-10"></a></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb3-12"><a href="#cb3-12"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-13"><a href="#cb3-13"></a>  <span class="kw">let</span> gdbScript <span class="ot">=</span> runBuilder script</span>
<span id="cb3-14"><a href="#cb3-14"></a>  renderIO gdbScript <span class="st">&quot;./script.gdb&quot;</span></span></code></pre></div>
<p>As you can see, it looks similar to the original script thanks to do-syntax and the EDSL that <code>debugger-hs</code> provides. When the Haskell code is executed, a GDB script is generated and saved as "script.gdb":</p>
<pre class="gdb"><code>break main.cpp:8
set $var0 = $bpnum

command $var0
  print x
  continue
end</code></pre>
<p>The script has the same behavior as before, but you may notice there's an extra statement: <code>$var0</code> is set to <code>$bpnum</code>. <code>$bpnum</code> is a magic variable that GDB uses to always keep track of the last breakpoint id that was generated. By setting <code>$var0</code> to this value, it makes it possible in the Haskell DSL to always know the id of the last set breakpoint (since <code>$bpnum</code> keeps changing with each breakpoint). The library manages all this automatically, making it possible to build other abstractions on top (as we will see in the next section).</p>
<p>Another thing to note is that once the Haskell code finishes executing, the produced script no longer contains any Haskell and consists 100% of GDB statements. This avoids potential lock-in to the library and it might also make it easier to introduce Haskell into the workplace.</p>
<h2 id="a-more-complex-example">A more complex example</h2>
<p>One situation that I often ran into while debugging was that I had to check if certain places in the code were triggered sequentially in order. In GDB, you could do this with a script that looks as follows:</p>
<pre class="gdb"><code>break func1

command 1
    break func2

    command 2
        ...
    end

    continue
end</code></pre>
<p>While this works, it gets unwieldy very fast with the ever increasing indentation. I would much rather write code that handles the first breakpoint <em>and then</em> handle the later breakpoints. If you've been coding in Haskell for some time, you know where I'm going with this.. <span class="emoji" data-emoji="wink">ðŸ˜‰</span></p>
<p>With <code>debugger-hs</code>, we can fix this problem by making good use of abstractions in Haskell. First we define a helper function that sets a breakpoint and then configures the actions that need to be run when the breakpoint is triggered:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="ot">withBreakpoint ::</span> <span class="dt">Location</span> <span class="ot">-&gt;</span> (<span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">Builder</span> ()) <span class="ot">-&gt;</span> <span class="dt">Builder</span> ()</span>
<span id="cb6-2"><a href="#cb6-2"></a>withBreakpoint loc f <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>  bp <span class="ot">&lt;-</span> <span class="fu">break</span> loc</span>
<span id="cb6-4"><a href="#cb6-4"></a>  command bp <span class="op">$</span> f bp</span></code></pre></div>
<p>With this helper function, we can now write code like this:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="ot">script ::</span> <span class="dt">Builder</span> ()</span>
<span id="cb7-2"><a href="#cb7-2"></a>script <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>  withBreakpoint (<span class="dt">Function</span> <span class="st">&quot;func1&quot;</span>) <span class="op">$</span> \bp1 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>    withBreakpoint (<span class="dt">Function</span> <span class="st">&quot;func2&quot;</span>) <span class="op">$</span> \bp2 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>      _  <span class="co">-- ...</span></span></code></pre></div>
<p>The indentation issue is still present, but our code is better factored now that the creation and processing of a breakpoint is handled in one place. But, we're not done yet. If you look closely, you'll see that we are making use of continuations now. This allows us to take the refactoring one step further using the continuation monad from <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Cont.html">Control.Monad.Cont</a>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="ot">script ::</span> <span class="dt">Builder</span> ()</span>
<span id="cb8-2"><a href="#cb8-2"></a>script <span class="ot">=</span> <span class="fu">flip</span> runContT handleResult <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>  bp1 <span class="ot">&lt;-</span> <span class="dt">ContT</span> <span class="op">$</span> withBreakpoint (<span class="dt">Function</span> <span class="st">&quot;func1&quot;</span>)</span>
<span id="cb8-4"><a href="#cb8-4"></a>  bp2 <span class="ot">&lt;-</span> <span class="dt">ContT</span> <span class="op">$</span> withBreakpoint (<span class="dt">Function</span> <span class="st">&quot;func2&quot;</span>)</span>
<span id="cb8-5"><a href="#cb8-5"></a>  <span class="co">-- ...</span></span>
<span id="cb8-6"><a href="#cb8-6"></a>  <span class="kw">where</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>    handleResult _ <span class="ot">=</span> <span class="fu">pure</span> ()</span></code></pre></div>
<p>The indentation is completely flat now and the code reads from top to bottom, which is more in-line with how the script actually runs.</p>
<p>In a more complex/realistic situation, we can now attach actions to each breakpoint by using <code>lift</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="ot">script ::</span> <span class="dt">Builder</span> ()</span>
<span id="cb9-2"><a href="#cb9-2"></a>script <span class="ot">=</span> <span class="fu">flip</span> runContT delete <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>  bp1 <span class="ot">&lt;-</span> <span class="dt">ContT</span> <span class="op">$</span> withBreakpoint (<span class="dt">Function</span> <span class="st">&quot;func1&quot;</span>)</span>
<span id="cb9-4"><a href="#cb9-4"></a>  lift <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb9-5"><a href="#cb9-5"></a>    <span class="co">-- ... actions to run for breakpoint 1</span></span>
<span id="cb9-6"><a href="#cb9-6"></a>    <span class="fu">print</span> <span class="st">&quot;x&quot;</span></span>
<span id="cb9-7"><a href="#cb9-7"></a>    <span class="fu">print</span> <span class="st">&quot;y&quot;</span></span>
<span id="cb9-8"><a href="#cb9-8"></a></span>
<span id="cb9-9"><a href="#cb9-9"></a>  bp2 <span class="ot">&lt;-</span> <span class="dt">ContT</span> <span class="op">$</span> withBreakpoint (<span class="dt">Function</span> <span class="st">&quot;func2&quot;</span>)</span>
<span id="cb9-10"><a href="#cb9-10"></a>  lift <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb9-11"><a href="#cb9-11"></a>    _  <span class="co">-- ... actions to run for breakpoint 2</span></span>
<span id="cb9-12"><a href="#cb9-12"></a></span>
<span id="cb9-13"><a href="#cb9-13"></a>  <span class="fu">pure</span> [bp1, bp2]</span></code></pre></div>
<p>This generates the GDB script below:</p>
<pre class="gdb"><code>break func1
set $var0 = $bpnum
command $var0
    # ... actions for breakpoint 1
    print x
    print y

    break func2
    set $var1 = $bpnum
    command $var1
        # ... actions for breakpoint 2

        delete $var0 $var1
    end
end</code></pre>
<p>Note also how the breakpoints are automatically cleaned up at the right location by passing in the <code>delete</code> function to <code>runContT</code>. This is another feature we got for free by making use of the continuation monad. Neat!</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this post I showed how we can make use of the new <a href="https://github.com/luc-tielen/debugger-hs.git">debugger-hs</a> library to create complex GDB scripts with little effort. The library is still in early stages, but it can already generate complex scripts thanks to Haskell's powerful abstraction capabilities and ecosystem. Some features I still plan to add to the library are LLDB support, increasing the coverage of GDB statements in the EDSL and improving the type safety in some places to prevent mistakes at compile time in Haskell.</p>
<p>If you need to use a debugger often and are unhappy with what GDB provides by default, give this library a shot and let me know on <a href="https://twitter.com/luctielen">Twitter</a> how it went!</p>]]></content>
  </entry>
  <entry>
      <title>Making LLVM GEP safer in Haskell</title>
      <link href="https://luctielen.com/posts/making_llvm_gep_safer_in_haskell"/>
      <id>https://luctielen.com/posts/making_llvm_gep_safer_in_haskell</id>
      <updated></updated>
      <category term="llvm"/>
      <category term="haskell"/>
      <summary></summary>
      <content type="html"><![CDATA[<p>In today's article, I will showcase how Haskell's typesystem can be used to simplify code generation and reduce the chance of bugs involving the LLVM <code>getelementptr</code> instruction.</p>
<h2 id="intro-to-the-gep-instruction">Intro to the GEP instruction</h2>
<p>LLVM as a compiler framework offers many different low-level instructions, one of which being the <a href="https://llvm.org/docs/LangRef.html#getelementptr-instruction"><code>getelementptr</code></a> instruction (commonly abbreviated as just "<code>gep</code>"). With <code>gep</code>, you can compute derived pointers/addresses of a nested type inside another data structure, starting from a pointer. It does this by making use of type information and a list of indices into the struct that are supplied.</p>
<p>Here's a small snippet of C++ code and the corresponding instructions that the compiler generates (some details omitted for clarity):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">struct</span> A {</span>
<span id="cb1-2"><a href="#cb1-2"></a>  <span class="dt">int</span> field1;</span>
<span id="cb1-3"><a href="#cb1-3"></a>  <span class="dt">double</span> field2;</span>
<span id="cb1-4"><a href="#cb1-4"></a>};</span>
<span id="cb1-5"><a href="#cb1-5"></a></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">struct</span> B {</span>
<span id="cb1-7"><a href="#cb1-7"></a>  A fieldA;</span>
<span id="cb1-8"><a href="#cb1-8"></a>  <span class="dt">int</span> values[<span class="dv">3</span>];</span>
<span id="cb1-9"><a href="#cb1-9"></a>};</span>
<span id="cb1-10"><a href="#cb1-10"></a></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="dt">void</span> func(B* b) {</span>
<span id="cb1-12"><a href="#cb1-12"></a>  b-&gt;fieldA.field2 = <span class="fl">123.456</span>;</span>
<span id="cb1-13"><a href="#cb1-13"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode ll"><code class="sourceCode llvm"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">; First some type definitions:</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="fu">%struct.B</span> = <span class="kw">type</span> { <span class="fu">%struct.A</span>, [<span class="dv">3</span> x <span class="dt">i32</span>] }</span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="fu">%struct.A</span> = <span class="kw">type</span> { <span class="dt">i32</span>, <span class="dt">double</span> }</span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co">; Instructions for function &quot;func&quot;:</span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="kw">define</span> dso_local <span class="dt">void</span> <span class="fu">@_Z4funcP1B</span>(<span class="fu">%struct.B</span>* <span class="fu">%0</span>) {</span>
<span id="cb2-7"><a href="#cb2-7"></a>  <span class="co">; Address to field2 is calculated:</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>  <span class="fu">%1</span> = <span class="kw">getelementptr</span> <span class="fu">%struct.B</span>, <span class="fu">%struct.B</span>* <span class="fu">%0</span>, <span class="dt">i32</span> <span class="dv">0</span>, <span class="dt">i32</span> <span class="dv">0</span>, <span class="dt">i32</span> <span class="dv">1</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>  <span class="co">; And 123.456 is written to it:</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>  <span class="kw">store</span> <span class="dt">double</span> <span class="dv">1</span>.234560e+<span class="dv">02</span>, <span class="dt">double</span>* <span class="fu">%1</span>, <span class="kw">align</span> <span class="dv">8</span></span>
<span id="cb2-11"><a href="#cb2-11"></a>  <span class="kw">ret</span> <span class="dt">void</span></span>
<span id="cb2-12"><a href="#cb2-12"></a>}</span></code></pre></div>
<p>If we take a closer look at the line with the gep instruction, we see that a list of indices is used to index into the B datastructure. The indices correspond with the following:</p>
<ol>
<li><strong>0</strong>: offset from the initial pointer to object of type B</li>
<li><strong>0</strong>: first field inside the B struct (= struct A)</li>
<li><strong>1</strong>: second field inside the A struct (= double)</li>
</ol>
<p>If we want to generate similar code using the llvm-hs library in Haskell, we need to write the following code:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="ot">codegen ::</span> <span class="dt">ModuleBuilder</span> ()</span>
<span id="cb3-2"><a href="#cb3-2"></a>codegen <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>  <span class="kw">let</span> doubleType <span class="ot">=</span> <span class="dt">FloatingPointType</span> <span class="dt">DoubleFP</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>  aType <span class="ot">&lt;-</span> typedef <span class="st">&quot;A&quot;</span> (<span class="dt">Just</span> <span class="op">$</span> <span class="dt">StructureType</span> <span class="dt">False</span> [i32, doubleType])</span>
<span id="cb3-5"><a href="#cb3-5"></a>  bType <span class="ot">&lt;-</span> typedef <span class="st">&quot;B&quot;</span> (<span class="dt">Just</span> <span class="op">$</span> <span class="dt">StructureType</span> <span class="dt">False</span> [aType, <span class="dt">ArrayType</span> <span class="dv">3</span> i32])</span>
<span id="cb3-6"><a href="#cb3-6"></a></span>
<span id="cb3-7"><a href="#cb3-7"></a>  function <span class="st">&quot;func&quot;</span> [(ptr bType, <span class="st">&quot;b&quot;</span>)] void <span class="op">$</span> \[b] <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>    pointer <span class="ot">&lt;-</span> gep b [int32 <span class="dv">0</span>, int32 <span class="dv">0</span>, int32 <span class="dv">1</span>]</span>
<span id="cb3-9"><a href="#cb3-9"></a>    store pointer <span class="dv">0</span> (double <span class="fl">123.456</span>)</span>
<span id="cb3-10"><a href="#cb3-10"></a>    retVoid</span>
<span id="cb3-11"><a href="#cb3-11"></a></span>
<span id="cb3-12"><a href="#cb3-12"></a>  <span class="fu">return</span> ()</span>
<span id="cb3-13"><a href="#cb3-13"></a></span>
<span id="cb3-14"><a href="#cb3-14"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb3-15"><a href="#cb3-15"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-16"><a href="#cb3-16"></a>  <span class="kw">let</span> moduleIR <span class="ot">=</span> buildModule <span class="st">&quot;example&quot;</span> codegen</span>
<span id="cb3-17"><a href="#cb3-17"></a>      output <span class="ot">=</span> ppllvm moduleIR</span>
<span id="cb3-18"><a href="#cb3-18"></a>  T.putStrLn output</span></code></pre></div>
<p>The translation is straight-forward, but the gep instruction has some problems:</p>
<ol>
<li>Types are indexed by integers: hard to remember which value corresponds to which type</li>
<li>Manual entry of indices: error-prone</li>
<li>Indices need to be repeated each time you use a gep: tedious</li>
<li>It is possible to provide an empty list of indices which doesn't make sense (it's basically a no-op)</li>
</ol>
<p>The good thing is that we have some options to fix these issues. Because we are using the Haskell bindings for LLVM, we can use Haskell as a "meta-programming" language for LLVM. Let's see what we can do.</p>
<h2 id="the-indices-datatype">The Indices datatype</h2>
<p>First of, we can start by making a dedicated Indices datatype, that handles the complexity of the gep instruction. For this to be possible, we need to take a few rules into account regarding the GEP instruction:</p>
<ol>
<li>A gep with just index 0 is a no-op (will return address of current pointer).</li>
<li>Two gep instructions can be combined if the result address of the first gep is used in the second instruction.</li>
<li>If geps are combined: if the first index of second gep is 0, it can be skipped (because of the first rule).</li>
</ol>
<p>Written in pseudo-code, this looks as follows:</p>
<ul>
<li>[0] = no-op</li>
<li>[0, 1] + [0, 2, 3] = [0, 1, 2, 3]</li>
<li>[0, 1] + [1, 2, 3] = [0, 1, 1, 2, 3]</li>
</ul>
<p>Given these rules, we can create the following datatype that takes all this into account:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">newtype</span> <span class="dt">Indices</span> <span class="ot">=</span> <span class="dt">Indices</span> (<span class="dt">NonEmpty</span> <span class="dt">Operand</span>)</span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="kw">instance</span> <span class="dt">Semigroup</span> <span class="dt">Indices</span> <span class="kw">where</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>  <span class="dt">Indices</span> lhs <span class="op">&lt;&gt;</span> <span class="dt">Indices</span> rhs <span class="ot">=</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>    <span class="kw">let</span> rhs&#39; <span class="ot">=</span> <span class="kw">if</span> NonEmpty.head rhs <span class="op">==</span> int32 <span class="dv">0</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>               <span class="kw">then</span> NonEmpty.tail rhs</span>
<span id="cb4-7"><a href="#cb4-7"></a>               <span class="kw">else</span> NonEmpty.toList rhs</span>
<span id="cb4-8"><a href="#cb4-8"></a>    <span class="kw">in</span> <span class="dt">Indices</span> <span class="op">$</span> NonEmpty.head lhs <span class="op">:|</span> (NonEmpty.tail lhs <span class="op">++</span> rhs&#39;)</span></code></pre></div>
<p>This newtype and Semigroup instance gets us quite far and allows us to compose indices together. However, there's nothing stopping us from composing indices together in the wrong order or in other incorrect ways, which can lead to an invalid list of indices. This can in turn potentially lead to weird bugs (that can only be observed at runtime) because of wrongly calculated pointer offsets.</p>
<h2 id="keeping-track-of-indices-at-the-type-level">Keeping track of indices at the type level</h2>
<p>Luckily, we can make use of Haskell's typesystem to prevent exactly these sources of bugs! If we think of the indices as a path used to index a data structure, we can make it so paths can only be composed if the end of the first path lines up with the start of the second path. We can keep track of this fact by using two phantom type variables representing the start and end of a path. This gives us the following data type:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">newtype</span> <span class="dt">Path</span> (<span class="ot">start ::</span> k) (<span class="ot">end ::</span> k) <span class="ot">=</span> <span class="dt">Path</span> (<span class="dt">NonEmpty</span> <span class="dt">Operand</span>)</span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="co">-- Next line prevents usage of `coerce` to bypass type-safety:</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="kw">type</span> role <span class="dt">Path</span> nominal nominal</span></code></pre></div>
<p>The phantom type variables give us additional type safety, but they have changed the kind of <code>Path</code> (to <code>k -&gt; k -&gt; Type</code>). This makes it incompatible with the <code>Semigroup</code> typeclass. This isn't too bad though, since we can think of a new function/operator to compose paths together.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="ot">(-&gt;&gt;) ::</span> <span class="dt">Path</span> a b <span class="ot">-&gt;</span> <span class="dt">Path</span> b c <span class="ot">-&gt;</span> <span class="dt">Path</span> a c</span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="dt">Path</span> a2b <span class="op">-&gt;&gt;</span> <span class="dt">Path</span> b2c <span class="ot">=</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>  <span class="kw">let</span> b2c&#39; <span class="ot">=</span> <span class="kw">if</span> NonEmpty.head b2c <span class="op">==</span> int32 <span class="dv">0</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>              <span class="kw">then</span> NonEmpty.tail b2c</span>
<span id="cb6-5"><a href="#cb6-5"></a>              <span class="kw">else</span> NonEmpty.toList b2c</span>
<span id="cb6-6"><a href="#cb6-6"></a>  <span class="kw">in</span> <span class="dt">Path</span> <span class="op">$</span> NonEmpty.head a2b <span class="op">:|</span> (NonEmpty.tail a2b <span class="op">++</span> b2c&#39;)</span></code></pre></div>
<p>Note: I tried writing a <code>Category</code> instance for <code>Path</code>, but it turns out that there's no good implementation for <code>id</code> that works in all situations. It does form a <code>Semigroupoid</code> (from the semigroupoids package), but I didn't want to pull in an extra dependency for just one type class/function.</p>
<p>Now that we have this <code>Path</code> datatype, we can create a type-safe drop-in replacement for the <code>gep</code> instruction:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="ot">addr ::</span> <span class="dt">Path</span> a b <span class="ot">-&gt;</span> <span class="dt">Operand</span> <span class="ot">-&gt;</span> <span class="dt">IRBuilderT</span> <span class="dt">ModuleBuilder</span> <span class="dt">Operand</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>addr path pointer <span class="ot">=</span> gep pointer (pathToIndices path)</span>
<span id="cb7-3"><a href="#cb7-3"></a>  <span class="kw">where</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="ot">    pathToIndices ::</span> <span class="dt">Path</span> a b <span class="ot">-&gt;</span> [<span class="dt">Operand</span>]</span>
<span id="cb7-5"><a href="#cb7-5"></a>    pathToIndices (<span class="dt">Path</span> a2b) <span class="ot">=</span> NonEmpty.toList a2b</span></code></pre></div>
<p>Because <code>gep</code> is often used in combination with <code>load</code> and <code>store</code> instructions, we can write additional helper functions to simplify these too:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="co">-- This works very similar to C: index into a structure, and then get (load)</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="co">-- the value at that address.</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="ot">deref ::</span> <span class="dt">Path</span> a b <span class="ot">-&gt;</span> <span class="dt">Operand</span> <span class="ot">-&gt;</span> <span class="dt">IRBuilderT</span> <span class="dt">ModuleBuilder</span> <span class="dt">Operand</span></span>
<span id="cb8-4"><a href="#cb8-4"></a>deref path pointer <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>  address <span class="ot">&lt;-</span> addr path pointer</span>
<span id="cb8-6"><a href="#cb8-6"></a>  load address <span class="dv">0</span></span>
<span id="cb8-7"><a href="#cb8-7"></a></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="co">-- Same comment applies here, but with storing a value at a specific address.</span></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="ot">assign ::</span> <span class="dt">Path</span> a b <span class="ot">-&gt;</span> <span class="dt">Operand</span> <span class="ot">-&gt;</span> <span class="dt">Operand</span> <span class="ot">-&gt;</span> <span class="dt">IRBuilderT</span> <span class="dt">ModuleBuilder</span> ()</span>
<span id="cb8-10"><a href="#cb8-10"></a>assign path pointer value <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-11"><a href="#cb8-11"></a>  dstAddr <span class="ot">&lt;-</span> addr path pointer</span>
<span id="cb8-12"><a href="#cb8-12"></a>  store dstAddr <span class="dv">0</span> value</span></code></pre></div>
<p>You can now even create a helper function to copy over specific parts of a datatype (a function I ended up using quite a bit when porting over C code!):</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="co">-- This copies a (sub-)datatype of src into dst (at the same index offset).</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="ot">copyPath ::</span> <span class="dt">Path</span> a b <span class="ot">-&gt;</span> <span class="dt">Operand</span> <span class="ot">-&gt;</span> <span class="dt">Operand</span> <span class="ot">-&gt;</span> <span class="dt">IRCodegen</span> r ()</span>
<span id="cb9-3"><a href="#cb9-3"></a>copyPath path src dst <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-4"><a href="#cb9-4"></a>  value <span class="ot">&lt;-</span> deref path src</span>
<span id="cb9-5"><a href="#cb9-5"></a>  assign path dst value</span></code></pre></div>
<p>Now that we're armed with all these helper functions, the only thing that is left is to create paths to index into our data structure and compose them together. Note that this is the only place now where you need to be careful constructing the path. Afterwards, the typesystem makes sure all derived paths are correct by construction.</p>
<p>We can now port the earlier mentioned C++ program to LLVM as follows:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="co">-- A helper datatype, so we can keep track of start and end of a Path</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="co">-- at the type level</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="kw">data</span> <span class="dt">Datatype</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>  <span class="ot">=</span> <span class="dt">A</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>  <span class="op">|</span> <span class="dt">B</span></span>
<span id="cb10-6"><a href="#cb10-6"></a>  <span class="op">|</span> <span class="dt">Field1</span></span>
<span id="cb10-7"><a href="#cb10-7"></a>  <span class="op">|</span> <span class="dt">Field2</span></span>
<span id="cb10-8"><a href="#cb10-8"></a>  <span class="op">|</span> <span class="dt">Value</span></span>
<span id="cb10-9"><a href="#cb10-9"></a>  <span class="op">|</span> <span class="dt">ArrayOf</span> <span class="dt">Datatype</span></span>
<span id="cb10-10"><a href="#cb10-10"></a></span>
<span id="cb10-11"><a href="#cb10-11"></a><span class="co">-- Note: Not all of these Paths are needed, but are added as examples</span></span>
<span id="cb10-12"><a href="#cb10-12"></a></span>
<span id="cb10-13"><a href="#cb10-13"></a><span class="ot">a ::</span> <span class="dt">Path</span> <span class="dt">&#39;B</span> <span class="dt">&#39;A</span></span>
<span id="cb10-14"><a href="#cb10-14"></a>a <span class="ot">=</span> <span class="dt">Path</span> (NonEmpty.fromList [int32 <span class="dv">0</span>, int32 <span class="dv">0</span>])</span>
<span id="cb10-15"><a href="#cb10-15"></a></span>
<span id="cb10-16"><a href="#cb10-16"></a><span class="ot">values ::</span> <span class="dt">Path</span> <span class="dt">&#39;B</span> (<span class="dt">&#39;ArrayOf</span> <span class="dt">&#39;Value</span>)</span>
<span id="cb10-17"><a href="#cb10-17"></a>values <span class="ot">=</span> <span class="dt">Path</span> (NonEmpty.fromList [int32 <span class="dv">0</span>, int32 <span class="dv">1</span>])</span>
<span id="cb10-18"><a href="#cb10-18"></a></span>
<span id="cb10-19"><a href="#cb10-19"></a><span class="ot">valueAt ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Path</span> <span class="dt">&#39;B</span> <span class="dt">&#39;Value</span></span>
<span id="cb10-20"><a href="#cb10-20"></a>valueAt i <span class="ot">=</span> <span class="dt">Path</span> (NonEmpty.fromList [int32 <span class="dv">0</span>, int32 <span class="dv">1</span>, int32 i])</span>
<span id="cb10-21"><a href="#cb10-21"></a></span>
<span id="cb10-22"><a href="#cb10-22"></a><span class="ot">field1 ::</span> <span class="dt">Path</span> <span class="dt">&#39;A</span> <span class="dt">&#39;Field1</span></span>
<span id="cb10-23"><a href="#cb10-23"></a>field1 <span class="ot">=</span> <span class="dt">Path</span> (NonEmpty.fromList [int32 <span class="dv">0</span>, int32 <span class="dv">0</span>])</span>
<span id="cb10-24"><a href="#cb10-24"></a></span>
<span id="cb10-25"><a href="#cb10-25"></a><span class="ot">field2 ::</span> <span class="dt">Path</span> <span class="dt">&#39;A</span> <span class="dt">&#39;Field2</span></span>
<span id="cb10-26"><a href="#cb10-26"></a>field2 <span class="ot">=</span> <span class="dt">Path</span> (NonEmpty.fromList [int32 <span class="dv">0</span>, int32 <span class="dv">1</span>])</span>
<span id="cb10-27"><a href="#cb10-27"></a></span>
<span id="cb10-28"><a href="#cb10-28"></a>codegen <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-29"><a href="#cb10-29"></a>  <span class="kw">let</span> doubleType <span class="ot">=</span> <span class="dt">FloatingPointType</span> <span class="dt">DoubleFP</span></span>
<span id="cb10-30"><a href="#cb10-30"></a>  aType <span class="ot">&lt;-</span> typedef <span class="st">&quot;A&quot;</span> (<span class="dt">Just</span> <span class="op">$</span> <span class="dt">StructureType</span> <span class="dt">False</span> [i32, doubleType])</span>
<span id="cb10-31"><a href="#cb10-31"></a>  bType <span class="ot">&lt;-</span> typedef <span class="st">&quot;B&quot;</span> (<span class="dt">Just</span> <span class="op">$</span> <span class="dt">StructureType</span> <span class="dt">False</span> [aType, <span class="dt">ArrayType</span> <span class="dv">3</span> i32])</span>
<span id="cb10-32"><a href="#cb10-32"></a></span>
<span id="cb10-33"><a href="#cb10-33"></a>  function <span class="st">&quot;func&quot;</span> [(ptr bType, <span class="st">&quot;b&quot;</span>)] void <span class="op">$</span> \[b] <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb10-34"><a href="#cb10-34"></a>    assign (a <span class="op">-&gt;&gt;</span> field2) b (Constant.double <span class="fl">123.456</span>)</span>
<span id="cb10-35"><a href="#cb10-35"></a>    retVoid</span>
<span id="cb10-36"><a href="#cb10-36"></a></span>
<span id="cb10-37"><a href="#cb10-37"></a>  <span class="fu">return</span> ()</span>
<span id="cb10-38"><a href="#cb10-38"></a></span>
<span id="cb10-39"><a href="#cb10-39"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb10-40"><a href="#cb10-40"></a>main <span class="ot">=</span> _ <span class="co">-- same as before</span></span></code></pre></div>
<p>And we can verify it still generates the correct LLVM code:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode ll"><code class="sourceCode llvm"><span id="cb11-1"><a href="#cb11-1"></a><span class="co">; ModuleID = &#39;example&#39;</span></span>
<span id="cb11-2"><a href="#cb11-2"></a></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="fu">%A</span> = <span class="kw">type</span> {<span class="dt">i32</span>, <span class="dt">double</span>}</span>
<span id="cb11-4"><a href="#cb11-4"></a></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="fu">%B</span> = <span class="kw">type</span> {<span class="fu">%A</span>, [<span class="dv">3</span> x <span class="dt">i32</span>]}</span>
<span id="cb11-6"><a href="#cb11-6"></a></span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="kw">define</span> external <span class="kw">ccc</span>  <span class="dt">void</span> <span class="fu">@func</span>(<span class="fu">%B</span>*  <span class="fu">%b_0</span>)    {</span>
<span id="cb11-8"><a href="#cb11-8"></a>  <span class="fu">%1</span> = <span class="kw">getelementptr</span>  <span class="fu">%B</span>, <span class="fu">%B</span>* <span class="fu">%b_0</span>, <span class="dt">i32</span> <span class="dv">0</span>, <span class="dt">i32</span> <span class="dv">0</span>, <span class="dt">i32</span> <span class="dv">1</span></span>
<span id="cb11-9"><a href="#cb11-9"></a>  <span class="kw">store</span>  <span class="dt">double</span> <span class="dv">1</span>.234560e2, <span class="dt">double</span>* <span class="fu">%1</span></span>
<span id="cb11-10"><a href="#cb11-10"></a>  <span class="kw">ret</span> <span class="dt">void</span></span>
<span id="cb11-11"><a href="#cb11-11"></a>}</span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>In this post I showed how we can make the LLVM <code>gep</code> instruction safer and easier to use in Haskell by making good use of the typesystem. If you want to see this idea being used in action, you can take a look at <a href="https://github.com/luc-tielen/eclair-lang/commit/db130e2fc3f24b556e262f92f33178e679c60410">this commit</a> where I managed to remove all raw <code>gep</code> instructions by making use of the <code>Path</code> abstraction. The code is slightly different compared to what is presented in this blogpost, but the idea is the same.</p>
<p>If you are interested in more content like this, follow me on <a href="https://twitter.com/luctielen">Twitter</a>. Feel free to contact me if you have any questions or comments about this topic.</p>]]></content>
  </entry>
  <entry>
      <title>Static analysis using Haskell and Datalog</title>
      <link href="https://luctielen.com/posts/static_analysis_using_haskell_and_datalog"/>
      <id>https://luctielen.com/posts/static_analysis_using_haskell_and_datalog</id>
      <updated></updated>
      <category term="haskell"/>
      <category term="datalog"/>
      <category term="static analysis"/>
      <summary></summary>
      <content type="html"><![CDATA[<p>In today's post, I will give a step-by-step tutorial how you can write sophisticated analyses in SoufflÃ© Datalog controlled by Haskell using the souffle-haskell library. In this article I will assume you've already read the <a href="https://github.com/luc-tielen/souffle-haskell">README</a> or watched this <a href="https://luctielen.com/videos/leverage_the_power_of_logic_programming/">talk</a> where I explain the basics of the library.</p>
<p>In this guide, I will use a name-shadowing analysis for a simple language as an example. The analysis is not that complicated, but it does allow me to showcase some of the more interesting aspects when mixing Datalog and Haskell.</p>
<h2 id="anatomy-of-an-analysis">Anatomy of an analysis</h2>
<p>If we look at an analysis from a bird's-eye view, it consists of a few steps:</p>
<ol>
<li>Determine what you want to analyze;</li>
<li>Decompose your analysis in terms of simple facts;</li>
<li>Traverse over your data, deducing simple facts along the way;</li>
<li>Compute derived facts in Datalog and process your data using the new-found results back in Haskell.</li>
</ol>
<p>In each of the following sections, we will go over each of these steps in more detail.</p>
<h3 id="find-something-to-analyze">Find something to analyze</h3>
<p>Before we can start writing an analysis, we will first need something that we can analyze! Here's a simple (though somewhat contrived) expression-based language that has support for scoped blocks of code and variable assignment:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">type</span> <span class="dt">Var</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">type</span> <span class="dt">Value</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>  <span class="ot">=</span> <span class="dt">Block</span> [<span class="dt">Expr</span>]</span>
<span id="cb1-7"><a href="#cb1-7"></a>  <span class="op">|</span> <span class="dt">Assign</span> <span class="dt">Var</span> <span class="dt">Value</span></span></code></pre></div>
<p>With this language, we can now create a small program:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">exampleExpr ::</span> <span class="dt">Expr</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>exampleExpr <span class="ot">=</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>  <span class="dt">Block</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>    [ <span class="dt">Assign</span> <span class="st">&quot;x&quot;</span> <span class="dv">123</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>    , <span class="dt">Block</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>      [ <span class="dt">Assign</span> <span class="st">&quot;x&quot;</span> <span class="dv">456</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>      ]</span>
<span id="cb2-8"><a href="#cb2-8"></a>    ]</span></code></pre></div>
<p>This corresponds with the following pseudo-code:</p>
<pre><code>{            // First scope starts here
  x = 123    //                                              &lt;â”€â”
  {          // Second scope starts here                       â”‚
    x = 456  // Should give warning, shadows first assignment â”€â”˜
  }
}</code></pre>
<p>With this language, you can also have another situation where a variable shadows a previously declared variable in the same scope:</p>
<pre><code>{
  x = 1  //                                  &lt;â”€â”
  x = 2  // Shadows variable on previous line â”€â”˜
}</code></pre>
<p>I won't be going over the second case in detail (to keep the article from becoming too long), but you can solve it in a comparable way as the first example.</p>
<h3 id="decompose-analysis-in-terms-of-facts">Decompose analysis in terms of facts</h3>
<p>So how did I determine in the previous examples that a variable was shadowed? I made certain observations (facts) about the code and then combined these facts to form conclusions about the data. This is very close to how a logic programming language like Datalog works!</p>
<p>For name shadowing, what are the basic facts? First of all, we need to keep track of which variables are defined in the program. Secondly, another important fact that we can use is which scopes are nested inside each other.</p>
<p>In Datalog, we can write a query that uses these facts to check for name shadowing:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode datalog"><code class="sourceCode datalog"><span id="cb5-1"><a href="#cb5-1"></a><span class="co">// Declarations for the facts and relations used in our analysis:</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="kw">.decl</span> define<span class="cn">(</span>scope<span class="cn">:</span> <span class="dt">symbol</span><span class="cn">,</span> variable<span class="cn">:</span> <span class="dt">symbol</span><span class="cn">)</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="kw">.decl</span> nested_scope<span class="cn">(</span>scope<span class="cn">:</span> <span class="dt">symbol</span><span class="cn">,</span> sub_scope<span class="cn">:</span> <span class="dt">symbol</span><span class="cn">)</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="kw">.decl</span> shadowed<span class="cn">(</span>variable<span class="cn">:</span> <span class="dt">symbol</span><span class="cn">)</span></span>
<span id="cb5-5"><a href="#cb5-5"></a></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="co">// All data coming from Haskell needs to be marked as inputs,</span></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="co">// the results of the analysis are marked as outputs.</span></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="kw">.input</span> define</span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="kw">.input</span> nested_scope</span>
<span id="cb5-10"><a href="#cb5-10"></a><span class="kw">.output</span> shadowed</span>
<span id="cb5-11"><a href="#cb5-11"></a></span>
<span id="cb5-12"><a href="#cb5-12"></a><span class="co">// Read this query as follows:</span></span>
<span id="cb5-13"><a href="#cb5-13"></a><span class="co">//</span></span>
<span id="cb5-14"><a href="#cb5-14"></a><span class="co">// A variable is shadowed iff:</span></span>
<span id="cb5-15"><a href="#cb5-15"></a><span class="co">// it is defined in a scope &#39;scope&#39;</span></span>
<span id="cb5-16"><a href="#cb5-16"></a><span class="co">// AND it is defined again in scope &#39;sub_scope&#39;</span></span>
<span id="cb5-17"><a href="#cb5-17"></a><span class="co">// AND &#39;sub_scope&#39; is a scope nested inside of &#39;scope&#39;.</span></span>
<span id="cb5-18"><a href="#cb5-18"></a>shadowed<span class="cn">(</span>variable<span class="cn">)</span> <span class="cn">:-</span></span>
<span id="cb5-19"><a href="#cb5-19"></a>  define<span class="cn">(</span>scope<span class="cn">,</span> variable<span class="cn">),</span></span>
<span id="cb5-20"><a href="#cb5-20"></a>  define<span class="cn">(</span>sub_scope<span class="cn">,</span> variable<span class="cn">),</span></span>
<span id="cb5-21"><a href="#cb5-21"></a>  nested_scope<span class="cn">(</span>scope<span class="cn">,</span> sub_scope<span class="cn">).</span></span></code></pre></div>
<p>That's all there is to it! As you can tell, the transformation from the logical description of the analysis to the actual Datalog code is quite straight-forward.</p>
<p>When creating your Datalog queries, you can either check for "positive" or "negative" scenarios. With positive scenarios, I mean Datalog queries that search which values match certain criteria. Negative scenarios on the other hand check if an error situation occurred (like in this example).</p>
<p>One final thing to note here is that in a more complete implementation the query would contain extra information (for example line numbers). This has some additional benefits:</p>
<ol>
<li>You can use the line numbers in your query results (e.g. compiler error messages).</li>
<li>You can check more things if you have more information (such as name shadowing in same scope).</li>
</ol>
<h3 id="deducing-facts-of-your-data">Deducing facts of your data</h3>
<p>Now that we have written our Datalog analysis (and saved it as <code>name_shadowing.dl</code>), we can start calling it from Haskell. For this we will need some code to bind to the corresponding Datalog code:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="co">-- A type for representing our Datalog program:</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="kw">data</span> <span class="dt">NameShadowing</span> <span class="ot">=</span> <span class="dt">NameShadowing</span></span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="co">-- Types that correspond with our Datalog facts:</span></span>
<span id="cb6-5"><a href="#cb6-5"></a></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="kw">type</span> <span class="dt">Scope</span> <span class="ot">=</span> <span class="dt">Int32</span></span>
<span id="cb6-7"><a href="#cb6-7"></a></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="kw">data</span> <span class="dt">Define</span> <span class="ot">=</span> <span class="dt">Define</span> <span class="dt">Scope</span> <span class="dt">Var</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>  <span class="kw">deriving</span> <span class="dt">Generic</span></span>
<span id="cb6-10"><a href="#cb6-10"></a></span>
<span id="cb6-11"><a href="#cb6-11"></a><span class="kw">data</span> <span class="dt">NestedScope</span></span>
<span id="cb6-12"><a href="#cb6-12"></a>  <span class="ot">=</span> <span class="dt">NestedScope</span></span>
<span id="cb6-13"><a href="#cb6-13"></a>  {<span class="ot"> _scope ::</span> <span class="dt">Scope</span></span>
<span id="cb6-14"><a href="#cb6-14"></a>  ,<span class="ot"> _subscope ::</span> <span class="dt">Scope</span></span>
<span id="cb6-15"><a href="#cb6-15"></a>  } <span class="kw">deriving</span> <span class="dt">Generic</span></span>
<span id="cb6-16"><a href="#cb6-16"></a></span>
<span id="cb6-17"><a href="#cb6-17"></a><span class="kw">data</span> <span class="dt">Shadowed</span> <span class="ot">=</span> <span class="dt">Shadowed</span> <span class="dt">Var</span></span>
<span id="cb6-18"><a href="#cb6-18"></a>  <span class="kw">deriving</span> (<span class="dt">Generic</span>, <span class="dt">Show</span>)</span>
<span id="cb6-19"><a href="#cb6-19"></a></span>
<span id="cb6-20"><a href="#cb6-20"></a><span class="co">-- Some instances for communicating between Haskell and Datalog:</span></span>
<span id="cb6-21"><a href="#cb6-21"></a></span>
<span id="cb6-22"><a href="#cb6-22"></a><span class="kw">instance</span> <span class="dt">S.Program</span> <span class="dt">NameShadowing</span> <span class="kw">where</span></span>
<span id="cb6-23"><a href="#cb6-23"></a>  <span class="kw">type</span> <span class="dt">ProgramFacts</span> <span class="dt">NameShadowing</span> <span class="ot">=</span> &#39;[<span class="dt">Shadowed</span>, <span class="dt">Define</span>, <span class="dt">NestedScope</span>]</span>
<span id="cb6-24"><a href="#cb6-24"></a>  programName <span class="ot">=</span> <span class="fu">const</span> <span class="st">&quot;name_shadowing&quot;</span></span>
<span id="cb6-25"><a href="#cb6-25"></a></span>
<span id="cb6-26"><a href="#cb6-26"></a><span class="kw">instance</span> <span class="dt">S.Fact</span> <span class="dt">Define</span> <span class="kw">where</span></span>
<span id="cb6-27"><a href="#cb6-27"></a>  <span class="kw">type</span> <span class="dt">FactDirection</span> <span class="dt">Define</span> <span class="ot">=</span> <span class="dt">&#39;S.Input</span></span>
<span id="cb6-28"><a href="#cb6-28"></a>  factName <span class="ot">=</span> <span class="fu">const</span> <span class="st">&quot;define&quot;</span></span>
<span id="cb6-29"><a href="#cb6-29"></a></span>
<span id="cb6-30"><a href="#cb6-30"></a><span class="kw">instance</span> <span class="dt">S.Fact</span> <span class="dt">NestedScope</span> <span class="kw">where</span></span>
<span id="cb6-31"><a href="#cb6-31"></a>  <span class="kw">type</span> <span class="dt">FactDirection</span> <span class="dt">NestedScope</span> <span class="ot">=</span> <span class="dt">&#39;S.Input</span></span>
<span id="cb6-32"><a href="#cb6-32"></a>  factName <span class="ot">=</span> <span class="fu">const</span> <span class="st">&quot;nested_scope&quot;</span></span>
<span id="cb6-33"><a href="#cb6-33"></a></span>
<span id="cb6-34"><a href="#cb6-34"></a><span class="kw">instance</span> <span class="dt">S.Fact</span> <span class="dt">Shadowed</span> <span class="kw">where</span></span>
<span id="cb6-35"><a href="#cb6-35"></a>  <span class="kw">type</span> <span class="dt">FactDirection</span> <span class="dt">Shadowed</span> <span class="ot">=</span> <span class="dt">&#39;S.Output</span></span>
<span id="cb6-36"><a href="#cb6-36"></a>  factName <span class="ot">=</span> <span class="fu">const</span> <span class="st">&quot;shadowed&quot;</span></span>
<span id="cb6-37"><a href="#cb6-37"></a></span>
<span id="cb6-38"><a href="#cb6-38"></a><span class="kw">instance</span> <span class="dt">S.Marshal</span> <span class="dt">Define</span></span>
<span id="cb6-39"><a href="#cb6-39"></a><span class="kw">instance</span> <span class="dt">S.Marshal</span> <span class="dt">NestedScope</span></span>
<span id="cb6-40"><a href="#cb6-40"></a><span class="kw">instance</span> <span class="dt">S.Marshal</span> <span class="dt">Shadowed</span></span></code></pre></div>
<p>This approach should look familiar if you've read the <a href="https://github.com/luc-tielen/souffle-haskell">souffle-haskell README</a>. Once we've written the binding code, we can write a function that traverses our data and deduces facts:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="ot">deduceFacts ::</span> <span class="dt">S.Handle</span> <span class="dt">NameShadowing</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">S.SouffleM</span> ()</span>
<span id="cb7-2"><a href="#cb7-2"></a>deduceFacts handle expr <span class="ot">=</span> runReaderT (go expr) rootScope</span>
<span id="cb7-3"><a href="#cb7-3"></a>  <span class="kw">where</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>    <span class="co">-- Our function needs to keep track of which scope it is in.</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>    <span class="co">-- Scope at root level is 0, every nested scope increases by 1.</span></span>
<span id="cb7-6"><a href="#cb7-6"></a>    <span class="co">-- We can use the Reader monad for keeping track of scope since</span></span>
<span id="cb7-7"><a href="#cb7-7"></a>    <span class="co">-- we only ever modify it locally and for the rest only</span></span>
<span id="cb7-8"><a href="#cb7-8"></a>    <span class="co">-- perform reads.</span></span>
<span id="cb7-9"><a href="#cb7-9"></a>    rootScope <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb7-10"><a href="#cb7-10"></a>    newScope s <span class="ot">=</span> s <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb7-11"><a href="#cb7-11"></a>    go expr <span class="ot">=</span> <span class="kw">case</span> expr <span class="kw">of</span></span>
<span id="cb7-12"><a href="#cb7-12"></a>      <span class="co">-- Assignments are simple: we lookup the current scope</span></span>
<span id="cb7-13"><a href="#cb7-13"></a>      <span class="co">-- and store the fact that a variable is defined at this scope.</span></span>
<span id="cb7-14"><a href="#cb7-14"></a>      <span class="dt">Assign</span> var _value <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb7-15"><a href="#cb7-15"></a>        currentScope <span class="ot">&lt;-</span> ask</span>
<span id="cb7-16"><a href="#cb7-16"></a>        S.addFact handle <span class="op">$</span> <span class="dt">Define</span> currentScope var</span>
<span id="cb7-17"><a href="#cb7-17"></a>      <span class="co">-- Blocks are more complicated since the scope changes when you</span></span>
<span id="cb7-18"><a href="#cb7-18"></a>      <span class="co">-- enter a block. We can use Reader here for easy access to the</span></span>
<span id="cb7-19"><a href="#cb7-19"></a>      <span class="co">-- scope info. If we are in a nested scope, then we can submit</span></span>
<span id="cb7-20"><a href="#cb7-20"></a>      <span class="co">-- this fact to Datalog as well.</span></span>
<span id="cb7-21"><a href="#cb7-21"></a>      <span class="dt">Block</span> exprs <span class="ot">-&gt;</span> local newScope <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb7-22"><a href="#cb7-22"></a>        currentScope <span class="ot">&lt;-</span> ask</span>
<span id="cb7-23"><a href="#cb7-23"></a>        when (currentScope <span class="op">&gt;</span> rootScope) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb7-24"><a href="#cb7-24"></a>          <span class="kw">let</span> prevScope <span class="ot">=</span> currentScope <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb7-25"><a href="#cb7-25"></a>          S.addFact handle <span class="op">$</span> <span class="dt">NestedScope</span> prevScope currentScope</span>
<span id="cb7-26"><a href="#cb7-26"></a>        <span class="co">-- Don&#39;t forget to handle the nested sub-expressions:</span></span>
<span id="cb7-27"><a href="#cb7-27"></a>        traverse_ go exprs</span></code></pre></div>
<p>Phew! That was a dense piece of code. Hopefully the comments in between helped reason about the code. As you can see, computing facts based on a single point of data is easy. If a fact is based on some context and it requires information about multiple places in the data, it gets a little more tricky. Here I used manual recursion and monads to solve this issue, but you are completely free to compute facts in any possible way based on the input data. (I haven't tried this out myself yet, but I have a feeling this might be a great fit for comonads..)</p>
<h3 id="processing-the-analysis-results">Processing the analysis results</h3>
<p>We are almost there! The final step is to run the analysis and use the computed results in the rest of your library or application code.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb8-2"><a href="#cb8-2"></a>main <span class="ot">=</span> S.runSouffle <span class="dt">NameShadowing</span> <span class="op">$</span> \<span class="kw">case</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span></span>
<span id="cb8-4"><a href="#cb8-4"></a>    liftIO <span class="op">$</span> <span class="fu">putStrLn</span> <span class="st">&quot;Failed to load program.&quot;</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>  <span class="dt">Just</span> prog <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb8-6"><a href="#cb8-6"></a>    deduceFacts prog exampleExpr</span>
<span id="cb8-7"><a href="#cb8-7"></a>    S.run prog</span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="ot">    shadowedVars ::</span> [<span class="dt">Shadowed</span>] <span class="ot">&lt;-</span> S.getFacts prog</span>
<span id="cb8-9"><a href="#cb8-9"></a>    <span class="co">-- Here we only print out the results, but you could</span></span>
<span id="cb8-10"><a href="#cb8-10"></a>    <span class="co">-- use the results for error reporting, optimizations, ...</span></span>
<span id="cb8-11"><a href="#cb8-11"></a>    liftIO <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb8-12"><a href="#cb8-12"></a>      <span class="fu">putStrLn</span> <span class="st">&quot;Shadowed variables in expression:&quot;</span></span>
<span id="cb8-13"><a href="#cb8-13"></a>      traverse_ <span class="fu">print</span> shadowedVars</span></code></pre></div>
<p>By the way, if you have multiple fact types you need to retrieve from SoufflÃ©, you can make clever use of Haskell's typesystem to collect all these different facts with very little code:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">data</span> <span class="dt">Fact1</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="kw">data</span> <span class="dt">Fact2</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="kw">data</span> <span class="dt">Fact3</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="kw">data</span> <span class="dt">AnalysisResult</span> <span class="ot">=</span> <span class="dt">AnalysisResult</span> [<span class="dt">Fact1</span>] [<span class="dt">Fact2</span>] [<span class="dt">Fact3</span>]</span>
<span id="cb9-5"><a href="#cb9-5"></a></span>
<span id="cb9-6"><a href="#cb9-6"></a>main <span class="ot">=</span> runSouffle <span class="dt">MyAnalysis</span> <span class="op">$</span> \<span class="kw">case</span></span>
<span id="cb9-7"><a href="#cb9-7"></a>  <span class="dt">Just</span> prog <span class="ot">-&gt;</span></span>
<span id="cb9-8"><a href="#cb9-8"></a>    <span class="co">-- For each of the following calls, `getFacts` will retrieve a different</span></span>
<span id="cb9-9"><a href="#cb9-9"></a>    <span class="co">-- type of fact (all based on type information):</span></span>
<span id="cb9-10"><a href="#cb9-10"></a>    result <span class="ot">&lt;-</span> <span class="dt">AnalysisResult</span> <span class="op">&lt;$&gt;</span> S.getFacts prog</span>
<span id="cb9-11"><a href="#cb9-11"></a>                             <span class="op">&lt;*&gt;</span> S.getFacts prog</span>
<span id="cb9-12"><a href="#cb9-12"></a>                             <span class="op">&lt;*&gt;</span> S.getFacts prog</span>
<span id="cb9-13"><a href="#cb9-13"></a>    <span class="co">-- etc...</span></span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>In today's post, I showed how you can use Datalog from your Haskell code to perform complex analyses. By first destructuring an analysis in terms of simple facts and then writing queries based on those facts, we can write our analyses in a way close to how we reason about our code.</p>
<p>In this article we focused on an analysis for a simple language, but this approach is not limited to this usecase. For example, you can also use it for when you need to process complex data in a webserver, in data science, ...</p>
<p>If you want to see a more complicated example of this approach, here's a <a href="https://github.com/luc-tielen/playground/blob/dead_code_elimination/src/Main.hs">dead code elimination</a> analysis. This example is more complicated than the one explained in this post and uses techniques like control flow analysis (in Datalog) to compute all dead code paths in a program. And if you really want to go all-in, you could structure your different analyses to gather all facts in a single traversal by <a href="/posts/combining_folds_using_semigroups">combining them into one fold</a>.</p>
<p>If you have any questions or thoughts about this article, let me know on <a href="https://twitter.com/luctielen/status/1418954922209460236">Twitter</a>. If you want to play around with the code from this post, it can be found <a href="https://github.com/luc-tielen/playground/blob/static_analysis_blogpost/src/Main.hs">here</a>.</p>]]></content>
  </entry>
  <entry>
      <title>Combining folds using semigroups</title>
      <link href="https://luctielen.com/posts/combining_folds_using_semigroups"/>
      <id>https://luctielen.com/posts/combining_folds_using_semigroups</id>
      <updated></updated>
      <category term="haskell"/>
      <summary></summary>
      <content type="html"><![CDATA[<p>In today's post, I will show how to combine many recursion-scheme folds using semigroups. For seasoned Haskellers using the library, this trick might be well known or obvious, but I decided to write it down anyway for the rest of us mere mortals <span class="emoji" data-emoji="smiley">ðŸ˜ƒ</span>. I will assume a little familiarity with recursion-schemes though. If this isn't the case, be sure to check out the (recently revised) <a href="https://github.com/recursion-schemes/recursion-schemes/">recursion-schemes README</a> for an introduction to the library.</p>
<h2 id="the-naive-or-straightforward-approach">The naive or straightforward approach</h2>
<p>For our running example, let's take the idea of "static analysis" in a compiler. Here, the compiler executes many checks to make sure a program is semantically valid. Implemented in a straightforward way, each check is an (effectful) function that does a full traversal of the program AST to collect the analysis results. If we simplify this idea, we end up with the following:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">import</span> <span class="dt">Data.Functor.Foldable</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">import</span> <span class="dt">Data.Functor.Foldable.TH</span></span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="co">-- Our AST data type:</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>  <span class="ot">=</span> <span class="dt">Constant</span> <span class="dt">Int</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>  <span class="op">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb1-8"><a href="#cb1-8"></a></span>
<span id="cb1-9"><a href="#cb1-9"></a>makeBaseFunctor &#39;<span class="dt">&#39;Expr</span></span>
<span id="cb1-10"><a href="#cb1-10"></a></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="co">-- 1 + 2 + 3</span></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="ot">expr ::</span> <span class="dt">Expr</span></span>
<span id="cb1-13"><a href="#cb1-13"></a>expr <span class="ot">=</span> <span class="dt">Constant</span> <span class="dv">1</span> <span class="ot">`Add`</span> <span class="dt">Constant</span> <span class="dv">2</span> <span class="ot">`Add`</span> <span class="dt">Constant</span> <span class="dv">3</span></span>
<span id="cb1-14"><a href="#cb1-14"></a></span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="co">-- An analysis pass is an effectful function (here IO is used</span></span>
<span id="cb1-16"><a href="#cb1-16"></a><span class="co">-- to print to the terminal):</span></span>
<span id="cb1-17"><a href="#cb1-17"></a></span>
<span id="cb1-18"><a href="#cb1-18"></a><span class="co">-- Two effectful functions that we want to combine:</span></span>
<span id="cb1-19"><a href="#cb1-19"></a>function1,<span class="ot"> function2 ::</span> <span class="dt">ExprF</span> (<span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb1-20"><a href="#cb1-20"></a>function1 <span class="ot">=</span> function <span class="st">&quot;function1:&quot;</span></span>
<span id="cb1-21"><a href="#cb1-21"></a>function2 <span class="ot">=</span> function <span class="st">&quot;function2:&quot;</span></span>
<span id="cb1-22"><a href="#cb1-22"></a></span>
<span id="cb1-23"><a href="#cb1-23"></a><span class="co">-- An effectful function, prints out a prefix + a textual description</span></span>
<span id="cb1-24"><a href="#cb1-24"></a><span class="co">-- of each node it encounters.</span></span>
<span id="cb1-25"><a href="#cb1-25"></a><span class="ot">function ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ExprF</span> (<span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb1-26"><a href="#cb1-26"></a>function prefix <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb1-27"><a href="#cb1-27"></a>  <span class="dt">ConstantF</span> x <span class="ot">-&gt;</span></span>
<span id="cb1-28"><a href="#cb1-28"></a>    <span class="fu">putStrLn</span> <span class="op">$</span> <span class="fu">unwords</span> [prefix, <span class="st">&quot;Constant&quot;</span>, <span class="fu">show</span> x]</span>
<span id="cb1-29"><a href="#cb1-29"></a>  <span class="dt">AddF</span> action1 action2 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb1-30"><a href="#cb1-30"></a>    action1</span>
<span id="cb1-31"><a href="#cb1-31"></a>    <span class="fu">putStrLn</span> <span class="op">$</span> <span class="fu">unwords</span> [prefix, <span class="st">&quot;Add&quot;</span>]</span>
<span id="cb1-32"><a href="#cb1-32"></a>    action2</span>
<span id="cb1-33"><a href="#cb1-33"></a></span>
<span id="cb1-34"><a href="#cb1-34"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1-35"><a href="#cb1-35"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-36"><a href="#cb1-36"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;Running function1:&quot;</span></span>
<span id="cb1-37"><a href="#cb1-37"></a>  results1 <span class="ot">&lt;-</span> cata function1 expr</span>
<span id="cb1-38"><a href="#cb1-38"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;Running function2:&quot;</span></span>
<span id="cb1-39"><a href="#cb1-39"></a>  results2 <span class="ot">&lt;-</span> cata function2 expr</span>
<span id="cb1-40"><a href="#cb1-40"></a>  <span class="co">-- ... do something with results</span></span></code></pre></div>
<p>Running the snippet above gives us the following output:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1"></a>$ <span class="ex">stack</span> run  <span class="co"># Assuming we are in a stack project</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="ex">Running</span> function1:</span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="ex">function1</span>: Constant 1</span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="ex">function1</span>: Add</span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="ex">function1</span>: Constant 2</span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="ex">function1</span>: Add</span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="ex">function1</span>: Constant 3</span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="ex">Running</span> function2:</span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="ex">function2</span>: Constant 1</span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="ex">function2</span>: Add</span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="ex">function2</span>: Constant 2</span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="ex">function2</span>: Add</span>
<span id="cb2-13"><a href="#cb2-13"></a><span class="ex">function2</span>: Constant 3</span></code></pre></div>
<p>You can see that each traversal happens one after the other. Ideally though, we would like to collect all analysis results using a single traversal/fold. Let's try and figure out how we can achieve that.</p>
<h2 id="attempt-1-using-function-composition">Attempt 1: Using function composition</h2>
<p>Others have already thought of ways to compose folds using recursion schemes. Tim Williams has a great <a href="https://github.com/willtim/recursion-schemes/raw/master/slides-final.pdf">presentation</a> about recursion schemes where he shows techniques for composing them. First of, there's sequential composition:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">-- Note: not valid Haskell, &#39;=&#39; is mathematical equality</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>cata f <span class="op">.</span> cata g <span class="ot">=</span> cata (f <span class="ot">`comp`</span> g) <span class="kw">where</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>  <span class="co">-- &#39;comp&#39; first applies the function &#39;y&#39;, unwraps a single layer of</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>  <span class="co">-- the Fix datastructure, and then finally applies the function &#39;x&#39;</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="ot">  comp ::</span> (f (<span class="dt">Fix</span> f) <span class="ot">-&gt;</span> <span class="dt">Fix</span> f)</span>
<span id="cb3-6"><a href="#cb3-6"></a>       <span class="ot">-&gt;</span> (g (<span class="dt">Fix</span> f) <span class="ot">-&gt;</span> <span class="dt">Fix</span> f)</span>
<span id="cb3-7"><a href="#cb3-7"></a>       <span class="ot">-&gt;</span> g (<span class="dt">Fix</span> f)</span>
<span id="cb3-8"><a href="#cb3-8"></a>       <span class="ot">-&gt;</span> <span class="dt">Fix</span> f</span>
<span id="cb3-9"><a href="#cb3-9"></a>  comp x y <span class="ot">=</span> x <span class="op">.</span> unfix <span class="op">.</span> y</span></code></pre></div>
<p>However, this approach is not applicable for our static analysis running example due to the types not lining up. The result of the first function (<code>g</code> / <code>y</code>) needs to return a datastructure wrapped in <code>Fix</code> (but we return a <code>IO ()</code> value).</p>
<p>The second approach Tim mentions (using the <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Arrow.html#v:-38--38--38-"><code>(&amp;&amp;&amp;)</code></a>-operator from <code>Control.Arrow</code>) <em>is</em> applicable:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a>cata f <span class="op">&amp;&amp;&amp;</span> cata g <span class="ot">=</span> cata alg <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>  <span class="co">-- f :: f a -&gt; a</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>  <span class="co">-- g :: f b -&gt; b</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="ot">  alg ::</span> f (a, b) <span class="ot">-&gt;</span> (a, b)</span>
<span id="cb4-5"><a href="#cb4-5"></a>  alg <span class="ot">=</span> f <span class="op">.</span> <span class="fu">fmap</span> <span class="fu">fst</span> <span class="op">&amp;&amp;&amp;</span> g <span class="op">.</span> <span class="fu">fmap</span> <span class="fu">snd</span></span></code></pre></div>
<p>For "simple" values, this works great. However, this approach has the same problem as before when you return a function or monadic result instead. To illustrate this, let's run the snippet below:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="co">-- Note that alg returns a tuple of two IO actions now, instead of one!</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="ot">alg ::</span> <span class="dt">ExprF</span> (<span class="dt">IO</span> (), <span class="dt">IO</span> ()) <span class="ot">-&gt;</span> (<span class="dt">IO</span> (), <span class="dt">IO</span> ())</span>
<span id="cb5-3"><a href="#cb5-3"></a>alg <span class="ot">=</span> (function1 <span class="op">.</span> <span class="fu">fmap</span> <span class="fu">fst</span>) <span class="op">&amp;&amp;&amp;</span> (function2 <span class="op">.</span> <span class="fu">fmap</span> <span class="fu">snd</span>)</span>
<span id="cb5-4"><a href="#cb5-4"></a></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb5-6"><a href="#cb5-6"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>  <span class="kw">let</span> (action1, action2) <span class="ot">=</span> cata alg expr</span>
<span id="cb5-8"><a href="#cb5-8"></a>  action1</span>
<span id="cb5-9"><a href="#cb5-9"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;action1 finished, now action2:&quot;</span></span>
<span id="cb5-10"><a href="#cb5-10"></a>  action2</span></code></pre></div>
<p>This gives us the following output:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1"></a>$ <span class="ex">stack</span> run</span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="ex">function1</span>: Constant 1</span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="ex">function1</span>: Add</span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="ex">function1</span>: Constant 2</span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="ex">function1</span>: Add</span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="ex">function1</span>: Constant 3</span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="ex">action1</span> finished, now action2:</span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="ex">function2</span>: Constant 1</span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="ex">function2</span>: Add</span>
<span id="cb6-10"><a href="#cb6-10"></a><span class="ex">function2</span>: Constant 2</span>
<span id="cb6-11"><a href="#cb6-11"></a><span class="ex">function2</span>: Add</span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="ex">function2</span>: Constant 3</span></code></pre></div>
<p>This is the same behavior as we had before. We perform only one fold now, but then we <em>still</em> have to run the actions separately. That's not what we want! Back to the drawing board!</p>
<h2 id="attempt-2-using-semigroups">Attempt 2: Using semigroups</h2>
<p>We tried some forms of composition so far that didn't work out, but luckily Haskell has many more ways of composing expressions together. One that is often used is <code>(&lt;&gt;)</code> / <code>mappend</code> from the <code>Semigroup</code> typeclass. Here's what that looks like:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb7-2"><a href="#cb7-2"></a>main <span class="ot">=</span> cata alg expr <span class="kw">where</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>  <span class="co">-- alg / function1 / function2 are a Semigroup because:</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>  <span class="co">-- A function is a Semigroup if it&#39;s result is a Semigroup;</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>  <span class="co">-- &#39;IO a&#39; is a Semigroup if &#39;a&#39; is a Semigroup;</span></span>
<span id="cb7-6"><a href="#cb7-6"></a>  <span class="co">-- () is a Semigroup.</span></span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="ot">  alg ::</span> <span class="dt">ExprF</span> (<span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb7-8"><a href="#cb7-8"></a>  alg <span class="ot">=</span> function1 <span class="op">&lt;&gt;</span> function2</span></code></pre></div>
<p>Effectively, this calls the 2 functions in a row, and then combines the results. Running this code shows all effectful actions are interleaved as we'd expect:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1"></a>$ <span class="ex">stack</span> run</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="ex">function1</span>: Constant 1</span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="ex">function2</span>: Constant 1</span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="ex">function1</span>: Add</span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="ex">function2</span>: Add</span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="ex">function1</span>: Constant 2</span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="ex">function2</span>: Constant 2</span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="ex">function1</span>: Add</span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="ex">function2</span>: Add</span>
<span id="cb8-10"><a href="#cb8-10"></a><span class="ex">function1</span>: Constant 3</span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="ex">function2</span>: Constant 3</span></code></pre></div>
<p>Great! This is exactly what we want. We do only one fold over the datastructure and all actions are interleaved!</p>
<h2 id="other-monads-than-io">Other monads than IO</h2>
<p>While the approach using semigroups is short and sweet, it is not always possible to use it directly. This is because the monad that is being used needs to have a Semigroup instance (and IO just so happens to have an implementation for it). With a little more code, we can work around this limitation:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="ot">compose ::</span> (<span class="dt">Monad</span> m, <span class="dt">Semigroup</span> b) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m b</span>
<span id="cb9-2"><a href="#cb9-2"></a>compose f g a <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>  result1 <span class="ot">&lt;-</span> f a</span>
<span id="cb9-4"><a href="#cb9-4"></a>  result2 <span class="ot">&lt;-</span> g a</span>
<span id="cb9-5"><a href="#cb9-5"></a>  <span class="fu">pure</span> <span class="op">$</span> result1 <span class="op">&lt;&gt;</span> result2</span>
<span id="cb9-6"><a href="#cb9-6"></a></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="co">-- Or using applicative notation:</span></span>
<span id="cb9-8"><a href="#cb9-8"></a><span class="ot">compose&#39; ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Semigroup</span> b) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> f b</span>
<span id="cb9-9"><a href="#cb9-9"></a>compose&#39; f g a <span class="ot">=</span> (<span class="op">&lt;&gt;</span>) <span class="op">&lt;$&gt;</span> f a <span class="op">&lt;*&gt;</span> g a</span>
<span id="cb9-10"><a href="#cb9-10"></a></span>
<span id="cb9-11"><a href="#cb9-11"></a><span class="co">-- If you only care about side effects, you could use (*&gt;)</span></span>
<span id="cb9-12"><a href="#cb9-12"></a><span class="co">-- instead of (&lt;&gt;) as well.</span></span>
<span id="cb9-13"><a href="#cb9-13"></a></span>
<span id="cb9-14"><a href="#cb9-14"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb9-15"><a href="#cb9-15"></a>main <span class="ot">=</span> cata alg expr <span class="kw">where</span></span>
<span id="cb9-16"><a href="#cb9-16"></a>  alg <span class="ot">=</span> compose function1 function2</span></code></pre></div>
<p>With the "compose" function, you can now also use the same approach for monads that don't implement Semigroup (such as Reader/State/...). Nice!</p>
<h2 id="wrapping-up">Wrapping up</h2>
<p>In this article I showed 3 approaches to combining many smaller folds into one fused fold. Though not all approaches may be applicable for a specific situation, there are always multiple options to choose from when combining functions in this way.</p>
<p>I need to point out that while I used the recursion-schemes library, the same approach is possible if you use "normal" recursive functions (but maybe with a little more work).</p>
<p>If you are interested in more content like this, follow me on <a href="https://twitter.com/luctielen">Twitter</a>. Feel free to contact me if you have any questions or comments about this topic.</p>]]></content>
  </entry>
  <entry>
      <title>Supercharge your handles using phantom types</title>
      <link href="https://luctielen.com/posts/supercharge_your_handles_with_phantom_types"/>
      <id>https://luctielen.com/posts/supercharge_your_handles_with_phantom_types</id>
      <updated></updated>
      <category term="haskell"/>
      <summary></summary>
      <content type="html"><![CDATA[<p>In this article, I show how to use phantom types in combination with the "Handle pattern" to create more type-safe and user-friendly APIs in Haskell. I do this based on my experience adding this idea to the <a href="https://github.com/luc-tielen/souffle-haskell">souffle-haskell</a> library.</p>
<h2 id="a-quick-recap">A quick recap</h2>
<p>Jasper van der Jeugt has <a href="https://jaspervdj.be/posts/2018-03-08-handle-pattern.html">blogged</a> about the handle pattern in the past. In summary, he recommends using handles when interfacing external services (such as a database or file) with Haskell. A handle type should be created representing access to that service; as well as functions for communicating with the external service using that handle.</p>
<p>Here's what the handle pattern could look like for an external key-value store:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="co">-- Internals of the handle data type are opaque for external users</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">data</span> <span class="dt">DBHandle</span></span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="ot">get ::</span> <span class="dt">DBHandle</span> <span class="ot">-&gt;</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">Value</span>)</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="ot">put ::</span> <span class="dt">DBHandle</span> <span class="ot">-&gt;</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<h2 id="applying-the-handle-pattern-to-souffle-haskell">Applying the handle pattern to souffle-haskell</h2>
<p>In the souffle-haskell library, the handle pattern also turned out to be a great fit. The library exposes functionality for communicating with the Souffle Datalog language, which can be viewed as an external resource. Here's what the top level API looks like (simplified):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">-- Handle type for communicating with the external Datalog program.</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="kw">data</span> <span class="dt">Handle</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="co">-- Monad for performing Souffle-related actions in.</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="kw">newtype</span> <span class="dt">SouffleM</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="co">-- Many different functions for communicating with Souffle.</span></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="co">-- Note how all of these functions take a handle as an argument.</span></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="ot">addFact ::</span> <span class="dt">Fact</span> a <span class="ot">=&gt;</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> ()</span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="ot">getFacts ::</span> <span class="dt">Fact</span> a <span class="ot">=&gt;</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> [a]</span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="ot">run ::</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> ()</span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="co">-- Many other similar functions..</span></span>
<span id="cb2-13"><a href="#cb2-13"></a></span>
<span id="cb2-14"><a href="#cb2-14"></a><span class="co">-- A function for running actions in the SouffleM monad.</span></span>
<span id="cb2-15"><a href="#cb2-15"></a><span class="co">-- Given a function that takes a handle as input and returns an action</span></span>
<span id="cb2-16"><a href="#cb2-16"></a><span class="co">-- in the SouffleM monad, this function will return the underlying IO action</span></span>
<span id="cb2-17"><a href="#cb2-17"></a><span class="co">-- that will perform all these Souffle-related actions.</span></span>
<span id="cb2-18"><a href="#cb2-18"></a><span class="ot">runSouffle ::</span> (<span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span></code></pre></div>
<p>The handle pattern helped to structure the API and to take care of resource management. However, you can still mis-use this API. For example, since facts have to be pre-defined for a Souffle program, it doesn't make sense to add a fact to a Souffle program that doesnt' understand it. Can we do better and prevent these kinds of logical mistakes?</p>
<h2 id="enter-the-phantom-types">Enter the phantom types</h2>
<p>If you take a look at the previous Haskell snippet, you will see that every function takes the handle datatype as an argument. This makes it a great candidate for doing compile-time checks based on type level information. To see how we could do this for the snippet above, let's first introduce a phantom type variable to our handle:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="ot">{-# LANGUAGE RoleAnnotations #-}</span></span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="co">-- &quot;prog&quot; is a type variable referring to a corresponding Datalog program</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="kw">data</span> <span class="dt">Handle</span> prog <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="co">-- The next line is needed to prevent users from coercing between</span></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="co">-- handles with different phantom types:</span></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="kw">type</span> role <span class="dt">Handle</span> nominal</span>
<span id="cb3-8"><a href="#cb3-8"></a></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="kw">newtype</span> <span class="dt">SouffleM</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb3-10"><a href="#cb3-10"></a></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="ot">addFact ::</span> <span class="dt">Fact</span> a <span class="ot">=&gt;</span> <span class="dt">Handle</span> prog <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> ()</span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="ot">getFacts ::</span> <span class="dt">Fact</span> a <span class="ot">=&gt;</span> <span class="dt">Handle</span> prog <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> [a]</span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="ot">run ::</span> <span class="dt">Handle</span> prog <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> ()</span>
<span id="cb3-14"><a href="#cb3-14"></a></span>
<span id="cb3-15"><a href="#cb3-15"></a><span class="co">-- Here we add an extra argument, so that Haskell can infer what type the</span></span>
<span id="cb3-16"><a href="#cb3-16"></a><span class="co">-- phantom type of the handle should be.</span></span>
<span id="cb3-17"><a href="#cb3-17"></a><span class="co">-- Note: another approach is to use &quot;TypeApplications&quot; (doesn&#39;t require an</span></span>
<span id="cb3-18"><a href="#cb3-18"></a><span class="co">-- extra argument) to tell Haskell what the type of &quot;prog&quot; should be.</span></span>
<span id="cb3-19"><a href="#cb3-19"></a><span class="ot">runSouffle ::</span> prog <span class="ot">-&gt;</span> (<span class="dt">Handle</span> prog <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span></code></pre></div>
<p>This phantom type variable by itself doesn't do that much yet except for catching some type errors, but it does give us a starting point to start adding information on the type-level. One way to do this is by adding a constraint (based on the phantom type) to limit the possible scenarios a function can be used in. Conceptually this looks as follows:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="ot">myConstrainedFunc ::</span> <span class="dt">MyConstraint</span> prog <span class="ot">=&gt;</span> <span class="dt">Handle</span> prog <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> ()</span></code></pre></div>
<h2 id="taking-it-a-step-further-with-typefamilies">Taking it a step further with TypeFamilies</h2>
<p>For simple usecases the above would suffice, but we need some more expressivity if we want to check that a fact isn't part of a Souffle program. To achieve this, we can make use of a combination of the TypeFamilies extension and "TypeError" in GHC to create sophisticated constraints at the type-level:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="co">-- Add these extensions to top of the file.</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="ot">{-# LANGUAGE StandaloneKindSignatures #-}</span></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></span>
<span id="cb5-7"><a href="#cb5-7"></a></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="co">-- With the approach introduced here, some type families will only</span></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="co">-- return a constraint in the error cases (containing a TypeError).</span></span>
<span id="cb5-10"><a href="#cb5-10"></a><span class="co">-- GHC will thus think the constraints are redundant.</span></span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="co">-- This turns off that warning.</span></span>
<span id="cb5-12"><a href="#cb5-12"></a><span class="ot">{-# OPTIONS_GHC -Wno-redundant-constraints #-}</span></span>
<span id="cb5-13"><a href="#cb5-13"></a></span>
<span id="cb5-14"><a href="#cb5-14"></a><span class="kw">import</span> <span class="dt">Data.Kind</span> (<span class="dt">Type</span>)</span>
<span id="cb5-15"><a href="#cb5-15"></a><span class="kw">import</span> <span class="dt">GHC.TypeLits</span></span>
<span id="cb5-16"><a href="#cb5-16"></a></span>
<span id="cb5-17"><a href="#cb5-17"></a><span class="co">-- Elem is a type family that checks if a type is contained in a</span></span>
<span id="cb5-18"><a href="#cb5-18"></a><span class="co">-- list of types. It returns a type-level boolean.</span></span>
<span id="cb5-19"><a href="#cb5-19"></a><span class="kw">type</span> <span class="dt">Elem</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> [<span class="dt">Type</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb5-20"><a href="#cb5-20"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Elem</span> a as <span class="kw">where</span></span>
<span id="cb5-21"><a href="#cb5-21"></a>  <span class="dt">Elem</span> _ &#39;[]       <span class="ot">=</span> <span class="dt">&#39;False</span></span>
<span id="cb5-22"><a href="#cb5-22"></a>  <span class="dt">Elem</span> x (x &#39;<span class="op">:</span> _)  <span class="ot">=</span> <span class="dt">&#39;True</span></span>
<span id="cb5-23"><a href="#cb5-23"></a>  <span class="dt">Elem</span> x (_ &#39;<span class="op">:</span> xs) <span class="ot">=</span> <span class="dt">Elem</span> x xs</span>
<span id="cb5-24"><a href="#cb5-24"></a></span>
<span id="cb5-25"><a href="#cb5-25"></a><span class="co">-- Example usage of Elem: x won&#39;t compile when you try to use it</span></span>
<span id="cb5-26"><a href="#cb5-26"></a><span class="co">-- However this gives us a rather cryptic error message:</span></span>
<span id="cb5-27"><a href="#cb5-27"></a><span class="co">--  â€¢ Couldn&#39;t match type â€˜&#39;Falseâ€™ with â€˜&#39;Trueâ€™</span></span>
<span id="cb5-28"><a href="#cb5-28"></a><span class="co">--      arising from a use of â€˜xâ€™</span></span>
<span id="cb5-29"><a href="#cb5-29"></a><span class="ot">x ::</span> <span class="dt">Elem</span> <span class="dt">Int</span> &#39;[<span class="dt">Char</span>, <span class="dt">Bool</span>] <span class="op">~</span> <span class="dt">&#39;True</span> <span class="ot">=&gt;</span> <span class="dt">Int</span></span>
<span id="cb5-30"><a href="#cb5-30"></a>x <span class="ot">=</span> <span class="dv">1234</span></span>
<span id="cb5-31"><a href="#cb5-31"></a></span>
<span id="cb5-32"><a href="#cb5-32"></a><span class="co">-- To improve this, let&#39;s add a type-level assertion.</span></span>
<span id="cb5-33"><a href="#cb5-33"></a><span class="co">-- If the assertion is satisfied, everything is ok.</span></span>
<span id="cb5-34"><a href="#cb5-34"></a><span class="co">-- If the assertion fails, a custom type error is returned to the user.</span></span>
<span id="cb5-35"><a href="#cb5-35"></a><span class="kw">type</span> <span class="dt">Assert</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ErrorMessage</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span></span>
<span id="cb5-36"><a href="#cb5-36"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Assert</span> condition message <span class="kw">where</span></span>
<span id="cb5-37"><a href="#cb5-37"></a>  <span class="dt">Assert</span> <span class="dt">&#39;True</span> _ <span class="ot">=</span> ()</span>
<span id="cb5-38"><a href="#cb5-38"></a>  <span class="dt">Assert</span> <span class="dt">&#39;False</span> msg <span class="ot">=</span> <span class="dt">TypeError</span> msg</span>
<span id="cb5-39"><a href="#cb5-39"></a></span>
<span id="cb5-40"><a href="#cb5-40"></a><span class="co">-- Example using Assert: y won&#39;t compile if a is not of type Bool,</span></span>
<span id="cb5-41"><a href="#cb5-41"></a><span class="co">-- giving us a custom type error instead.</span></span>
<span id="cb5-42"><a href="#cb5-42"></a><span class="ot">constrainedId ::</span> <span class="dt">Assert</span> (<span class="dt">Elem</span> a &#39;[<span class="dt">Bool</span>]) (<span class="dt">&#39;ShowType</span> <span class="st">&quot;This won&#39;t compile!&quot;</span>)</span>
<span id="cb5-43"><a href="#cb5-43"></a>              <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb5-44"><a href="#cb5-44"></a>constrainedId <span class="ot">=</span> <span class="fu">id</span></span></code></pre></div>
<p>It is now possible to write a check to see if a fact is contained in a Souffle program:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="co">-- Type family for declaring which fact types belong to a Souffle program</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="kw">type</span> <span class="dt">ProgramFacts</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> [<span class="dt">Type</span>]</span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">ProgramFacts</span> a</span>
<span id="cb6-4"><a href="#cb6-4"></a></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="co">-- The actual check to see if a program contains a certain fact type</span></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="kw">type</span> <span class="dt">ContainsFact</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">ContainsFact</span> prog fact <span class="kw">where</span></span>
<span id="cb6-8"><a href="#cb6-8"></a>  <span class="dt">ContainsFact</span> prog fact <span class="ot">=</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>    <span class="dt">Assert</span> (<span class="dt">Elem</span> fact (<span class="dt">ProgramFacts</span> prog))</span>
<span id="cb6-10"><a href="#cb6-10"></a>           (<span class="dt">&#39;ShowType</span> <span class="st">&quot;Unknown fact for Souffle program&quot;</span>)</span></code></pre></div>
<p>We can now add this type-level assertion to our initial Haskell snippet:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="ot">addFact ::</span> (<span class="dt">Fact</span> a, <span class="dt">ContainsFact</span> prog a) <span class="ot">=&gt;</span> <span class="dt">Handle</span> prog <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> ()</span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="ot">getFacts ::</span> (<span class="dt">Fact</span> a, <span class="dt">ContainsFact</span> prog a) <span class="ot">=&gt;</span> <span class="dt">Handle</span> prog <span class="ot">-&gt;</span> <span class="dt">SouffleM</span> [a]</span>
<span id="cb7-3"><a href="#cb7-3"></a></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="co">-- Rest unmodified..</span></span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a></span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="co">-- In our application code we can specify that Fact1 and Fact2 belong to</span></span>
<span id="cb7-8"><a href="#cb7-8"></a><span class="co">-- the Souffle program managed by &#39;MyProgram&#39;:</span></span>
<span id="cb7-9"><a href="#cb7-9"></a></span>
<span id="cb7-10"><a href="#cb7-10"></a><span class="kw">data</span> <span class="dt">MyProgram</span> <span class="ot">=</span> <span class="dt">MyProgram</span></span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="kw">data</span> <span class="dt">Fact1</span> <span class="ot">=</span> <span class="dt">Fact1</span> <span class="dt">String</span></span>
<span id="cb7-12"><a href="#cb7-12"></a><span class="kw">data</span> <span class="dt">Fact2</span> <span class="ot">=</span> <span class="dt">Fact2</span> <span class="dt">String</span></span>
<span id="cb7-13"><a href="#cb7-13"></a></span>
<span id="cb7-14"><a href="#cb7-14"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">ProgramFacts</span> <span class="dt">MyProgram</span> <span class="ot">=</span> &#39;[<span class="dt">Fact1</span>, <span class="dt">Fact2</span>]</span></code></pre></div>
<p>If we now try to add a fact to a Souffle program that doesn't understand it, it won't compile anymore. Great!</p>
<h2 id="conclusion">Conclusion</h2>
<p>Phantom types are a lightweight and powerful technique for adding more type-safety to your code. Combined with the handle pattern and type families, it allows you to write expressive type-level assertions that are verified by the compiler.</p>
<p>Like mentioned before, the code in the post is based on my souffle-haskell library. I simplified the types in this post to keep the mental overhead as minimal as possible. Here's the <a href="https://github.com/luc-tielen/souffle-haskell/commit/4839959a9b2f45198747355466f066d768c6059a">original commit</a> where I introduced the idea in the code.</p>
<p>If you are interested in more content like this, follow me on <a href="https://twitter.com/luctielen">Twitter</a>. Feel free to contact me if you have any questions or comments about this topic.</p>]]></content>
  </entry>
  <entry>
      <title>Calling C++ from Haskell</title>
      <link href="https://luctielen.com/posts/calling_cpp_from_haskell"/>
      <id>https://luctielen.com/posts/calling_cpp_from_haskell</id>
      <updated></updated>
      <category term="haskell"/>
      <category term="c++"/>
      <summary></summary>
      <content type="html"><![CDATA[<p>In today's blogpost, I will show an approach for calling C++ code from Haskell. This can be useful in case you need the extra performance from C++ or if there is no library in the Haskell ecosystem that provides the functionality you need (but there is a C++ library for it).</p>
<p>The code snippets in this article are kept "simple" (though I will assume some C++ knowledge, since you will need to write some extra C++ code when binding to Haskell). The examples are derived from my <a href="https://github.com/luc-tielen/souffle-haskell.git">souffle-haskell library</a>, where I had to write Haskell bindings to interact with the SoufflÃ© datalog language.</p>
<h2 id="binding-to-c">Binding to C++</h2>
<p>If a library is meant to be used from many other languages, most of the time it will provide a C API for doing so. C has a relatively small feature-set and a well-defined, stable ABI (binary interface). On top of that, most languages have good support for interacting with C via a foreign function interface (FFI), making it straight-forward to interface with C.</p>
<p>However, for some libraries this is not the case. SoufflÃ© for example provides only a <a href="https://souffle-lang.github.io/interface">C++ interface</a>. C++ is a lot bigger language compared to C, has no stable ABI between different versions / compilers and contains many complex features such as overloadable functions and operators, templates, destructors, ... This makes binding to it a lot more complicated than C.</p>
<p>The trick is to write an extra layer between the existing Haskell and C++ code, that exposes functionality using the C ABI. Fortunately, C++ offers an easy way to be compatible with the C ABI with the <em>extern</em> keyword. The snippet below defines a function "answer_to_everything" that can be called from C (and thus also from other languages!):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> {</span>
<span id="cb1-2"><a href="#cb1-2"></a>  <span class="dt">int</span> answer_to_everything(<span class="dt">bool</span> arg);</span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a>  <span class="dt">int</span> answer_to_everything(<span class="dt">bool</span> arg) {</span>
<span id="cb1-5"><a href="#cb1-5"></a>    <span class="cf">return</span> <span class="dv">42</span>;</span>
<span id="cb1-6"><a href="#cb1-6"></a>  }</span>
<span id="cb1-7"><a href="#cb1-7"></a>}</span></code></pre></div>
<p>When using extern, you can still use C++-specific functionality inside the body of a function, but the signature of the function needs to be compatible with C.</p>
<p>If you wanted to, you could now start using this function in Haskell after importing it with a so-called <em>foreign import</em>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a>foreign <span class="kw">import</span> ccall unsafe &quot;answer_to_everything&quot; answerToEverything</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="ot">  ::</span> <span class="dt">CBool</span> <span class="ot">-&gt;</span> <span class="dt">CInt</span></span></code></pre></div>
<p>A foreign import is Haskell's way of importing C-compatible functions. Note that unlike Haskell modules, you will need to import foreign functions on a per-function basis. The syntax is as follows:</p>
<ul>
<li><em>foreign import ccall</em>: We're importing a foreign function!</li>
<li><em>unsafe</em>: This tells the Haskell compiler that the foreign function will not call back into Haskell. This results in less overhead when crossing language boundaries but you should only use the keyword when this is really the case!</li>
<li><em>"answer_to_everything"</em>: The name of the function (as defined in C++)</li>
<li><em>answerToEverything</em>: The name of the function (in Haskell)</li>
<li>Type signature: You need to manually add a type signature here, using the types defined in <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-C-Types.html">Foreign.C.Types</a>. Depending on if the function is pure or not, you also should wrap the result in IO. The Haskell compiler blindly trusts you as a programmer to provide the correct signature. If you make a mistake here, <em>bad things will happen</em><span class="emoji" data-emoji="tm">â„¢ï¸</span>, so be sure to get it right.</li>
</ul>
<h3 id="memory-management-and-objects">Memory management and objects</h3>
<p>Now that we know how to cross the language border and use a simple C++ function from Haskell, we can focus on other more complicated concepts.</p>
<p>First of all, there's memory management. Haskell uses a a garbage collector to clean up unused memory automatically. This is in contrast with C++, which is much "closer to the metal". C++ gives you very fine-grained control of the memory layout of an object and when exactly to allocate or free the memory of an object. If we want to bind C++ to Haskell, <strong>we have to make sure both languages work well together</strong>. One way to achieve this is by letting Haskell be in charge and call into the C++ code. Objects used via the FFI need to be allocated on the C++ heap, so they don't automatically get cleaned up once the object goes out of scope (like stack-allocated objects would). After objects are no longer in use, they need to be cleaned up again (also from the Haskell side).</p>
<p>The next issue are <em>the objects themselves</em>. The C ABI has no support for objects or calling methods on those objects. This isn't a problem though, since objects can be represented as an (opaque) C-like struct, together with functions that perform actions with that struct. Each of the functions has the same signature as the corresponding method of the object, except the function takes an additional argument for the pointer to the object. (In C++ this is handled implicitly for you with the <em>this</em> pointer.) Constructors and destructors also need to have their own separate functions in the FFI.</p>
<p>Taking all this into account, our FFI layer for managing a C++ object could look like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">// Suppose we want to call into this object from Haskell:</span></span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="kw">class</span> Example {</span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="kw">public</span>:</span>
<span id="cb3-5"><a href="#cb3-5"></a>  <span class="co">// Note: Constructor and destructor are auto-generated here!</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>  <span class="co">// We will have to add functions for calling these as well.</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>  <span class="dt">bool</span> do_stuff(<span class="dt">int</span> arg);</span>
<span id="cb3-8"><a href="#cb3-8"></a>};</span>
<span id="cb3-9"><a href="#cb3-9"></a></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="co">// We can define the following FFI layer:</span></span>
<span id="cb3-11"><a href="#cb3-11"></a></span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="co">// in ffi.h</span></span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> {</span>
<span id="cb3-14"><a href="#cb3-14"></a>  <span class="kw">typedef</span> <span class="kw">struct</span> ffi_example;</span>
<span id="cb3-15"><a href="#cb3-15"></a></span>
<span id="cb3-16"><a href="#cb3-16"></a>  ffi_example* example_create();</span>
<span id="cb3-17"><a href="#cb3-17"></a>  <span class="dt">void</span> example_destroy(ffi_example* object);</span>
<span id="cb3-18"><a href="#cb3-18"></a>  <span class="dt">bool</span> example_do_stuff(ffi_example* object, <span class="dt">int</span> arg);</span>
<span id="cb3-19"><a href="#cb3-19"></a>}</span>
<span id="cb3-20"><a href="#cb3-20"></a></span>
<span id="cb3-21"><a href="#cb3-21"></a><span class="co">// in ffi.cpp</span></span>
<span id="cb3-22"><a href="#cb3-22"></a><span class="pp">#include </span><span class="im">&quot;ffi.h&quot;</span></span>
<span id="cb3-23"><a href="#cb3-23"></a></span>
<span id="cb3-24"><a href="#cb3-24"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> {</span>
<span id="cb3-25"><a href="#cb3-25"></a></span>
<span id="cb3-26"><a href="#cb3-26"></a>ffi_example* example_create() {</span>
<span id="cb3-27"><a href="#cb3-27"></a>  <span class="kw">auto</span> object = <span class="kw">new</span> Example();</span>
<span id="cb3-28"><a href="#cb3-28"></a>  <span class="cf">return</span> <span class="kw">reinterpret_cast</span>&lt;ffi_example*&gt;(object);</span>
<span id="cb3-29"><a href="#cb3-29"></a>}</span>
<span id="cb3-30"><a href="#cb3-30"></a></span>
<span id="cb3-31"><a href="#cb3-31"></a><span class="dt">void</span> example_destroy(ffi_example* object) {</span>
<span id="cb3-32"><a href="#cb3-32"></a>  <span class="kw">auto</span> example = <span class="kw">reinterpret_cast</span>&lt;Example*&gt;(object);</span>
<span id="cb3-33"><a href="#cb3-33"></a>  <span class="kw">delete</span> example;</span>
<span id="cb3-34"><a href="#cb3-34"></a>}</span>
<span id="cb3-35"><a href="#cb3-35"></a></span>
<span id="cb3-36"><a href="#cb3-36"></a><span class="dt">bool</span> example_do_stuff(ffi_example* object, <span class="dt">int</span> arg) {</span>
<span id="cb3-37"><a href="#cb3-37"></a>  <span class="kw">auto</span> example = <span class="kw">reinterpret_cast</span>&lt;Example*&gt;(object);</span>
<span id="cb3-38"><a href="#cb3-38"></a>  <span class="cf">return</span> example-&gt;do_stuff(arg);</span>
<span id="cb3-39"><a href="#cb3-39"></a>}</span>
<span id="cb3-40"><a href="#cb3-40"></a></span>
<span id="cb3-41"><a href="#cb3-41"></a>}</span></code></pre></div>
<p>Now that we have the C++ part, we still need to write the Haskell part. To do this, we use an API from the Haskell <em>base</em> library for interacting with foreign functions. It provides data types that have a 1-to-1 correspondence with their C equivalents (for example <em>CInt</em>, <em>CBool</em>, ...). The <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-Ptr.html#t:Ptr">Ptr</a> data type is used for managing pointers from Haskell. The <em>Ptr</em> type uses a phantom type variable as a type-level tag to detect at compile time if you use a pointer of an unexpected type.</p>
<p>You may have noticed in the last C++ snippet that there was a manual call to <em>delete</em>. This is frowned upon in C++ nowadays since it can be very easy to make a mistake and forget to call <em>delete</em> in certain code paths (for example if an exception occurred). C++ has a solution for this in the form of so-called <em>smart pointers</em> but those are unusable in combination with the FFI. Haskell has a very similar mechanism though, called <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-ForeignPtr.html#t:ForeignPtr">foreign pointers</a>. A foreign pointer is a pointer managed by the Haskell runtime / garbage collector, coupled with a finalizer function for freeing up the memory used by the pointer. When the foreign pointer goes out of scope and there are no more references to it in the Haskell runtime, it will call the finalizer function.</p>
<p>Continuing with the <em>Example</em> class from earlier, we can now make sure the destructor is always called when the object goes out of scope:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="co">-- An empty data type, used as a type tag for the Ptr type</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="kw">data</span> <span class="dt">Example</span></span>
<span id="cb4-3"><a href="#cb4-3"></a></span>
<span id="cb4-4"><a href="#cb4-4"></a>foreign <span class="kw">import</span> ccall unsafe &quot;example_create&quot; exampleCreate</span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="ot">  ::</span> <span class="dt">IO</span> (<span class="dt">Ptr</span> <span class="dt">Example</span>)</span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="co">-- Slightly different syntax, this gives us a function pointer to the</span></span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="co">-- &quot;example_destroy&quot; function (needed below):</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>foreign <span class="kw">import</span> ccall unsafe &quot;&amp;example_destroy&quot; exampleDestroy</span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="ot">  ::</span> <span class="dt">FunPtr</span> (<span class="dt">Ptr</span> <span class="dt">Example</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ())</span>
<span id="cb4-10"><a href="#cb4-10"></a>foreign <span class="kw">import</span> ccall unsafe &quot;example_do_stuff&quot; exampleDoStuff</span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="ot">  ::</span> <span class="dt">Ptr</span> <span class="dt">Example</span> <span class="ot">-&gt;</span> <span class="dt">CInt</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">CBool</span></span>
<span id="cb4-12"><a href="#cb4-12"></a></span>
<span id="cb4-13"><a href="#cb4-13"></a><span class="co">-- This initializes a Example object on the heap, that will be</span></span>
<span id="cb4-14"><a href="#cb4-14"></a><span class="co">-- cleaned up with &quot;exampleDestroy&quot; when it is no longer in use.</span></span>
<span id="cb4-15"><a href="#cb4-15"></a><span class="ot">mkExample ::</span> <span class="dt">IO</span> (<span class="dt">ForeignPtr</span> <span class="dt">Example</span>)</span>
<span id="cb4-16"><a href="#cb4-16"></a>mkExample <span class="ot">=</span> mask_ <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb4-17"><a href="#cb4-17"></a>  <span class="co">-- mask_ is needed to avoid leaking the pointer in case an async exception</span></span>
<span id="cb4-18"><a href="#cb4-18"></a>  <span class="co">-- occurs between allocation and wrapping it in a foreign pointer.</span></span>
<span id="cb4-19"><a href="#cb4-19"></a>  ptr <span class="ot">&lt;-</span> exampleCreate</span>
<span id="cb4-20"><a href="#cb4-20"></a>  newForeignPtr exampleDestroy ptr</span>
<span id="cb4-21"><a href="#cb4-21"></a></span>
<span id="cb4-22"><a href="#cb4-22"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb4-23"><a href="#cb4-23"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-24"><a href="#cb4-24"></a>  obj <span class="ot">&lt;-</span> mkExample</span>
<span id="cb4-25"><a href="#cb4-25"></a>  <span class="co">-- Now we can use the pointer by unwrapping it with &quot;withForeignPtr&quot;:</span></span>
<span id="cb4-26"><a href="#cb4-26"></a>  withForeignPtr obj <span class="op">$</span> \ptr <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb4-27"><a href="#cb4-27"></a>    result <span class="ot">&lt;-</span> exampleDoStuff ptr <span class="dv">1234</span></span>
<span id="cb4-28"><a href="#cb4-28"></a>    <span class="fu">print</span> result  <span class="co">-- Process the result.</span></span></code></pre></div>
<h3 id="overloads">Overloads</h3>
<p>C++ has support for <em>overloadable functions</em> (functions with the same name and scope, but with different type signatures and function bodies). However, this is again not supported in C and as such is not possible to do in the FFI. If we want to be able to call these overloads, we have to wrap each variant with a helper function that is exposed in the FFI. If we add an overload to our Example class defined earlier, we can expose overloaded functions as follows:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">class</span> Example {</span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="kw">public</span>:</span>
<span id="cb5-3"><a href="#cb5-3"></a>  <span class="dt">bool</span> do_stuff(<span class="dt">int</span> arg);</span>
<span id="cb5-4"><a href="#cb5-4"></a>  <span class="dt">bool</span> do_stuff(<span class="dt">float</span> arg);  <span class="co">// &lt;- This overload is new.</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>};</span>
<span id="cb5-6"><a href="#cb5-6"></a></span>
<span id="cb5-7"><a href="#cb5-7"></a></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="co">// in ffi.h</span></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> {</span>
<span id="cb5-10"><a href="#cb5-10"></a>  <span class="co">// Rest of code is same as before.</span></span>
<span id="cb5-11"><a href="#cb5-11"></a></span>
<span id="cb5-12"><a href="#cb5-12"></a>  <span class="co">// The FFI functions all need a unique name.</span></span>
<span id="cb5-13"><a href="#cb5-13"></a>  <span class="dt">bool</span> example_do_stuff_int(ffi_example* object, <span class="dt">int</span> arg);</span>
<span id="cb5-14"><a href="#cb5-14"></a>  <span class="dt">bool</span> example_do_stuff_float(ffi_example* object, <span class="dt">float</span> arg);</span>
<span id="cb5-15"><a href="#cb5-15"></a>  <span class="co">// ... add other variants as needed.</span></span>
<span id="cb5-16"><a href="#cb5-16"></a>}</span>
<span id="cb5-17"><a href="#cb5-17"></a></span>
<span id="cb5-18"><a href="#cb5-18"></a><span class="co">// in ffi.cpp</span></span>
<span id="cb5-19"><a href="#cb5-19"></a><span class="pp">#include </span><span class="im">&quot;ffi.h&quot;</span></span>
<span id="cb5-20"><a href="#cb5-20"></a></span>
<span id="cb5-21"><a href="#cb5-21"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> {</span>
<span id="cb5-22"><a href="#cb5-22"></a><span class="co">// Rest of code is same as before.</span></span>
<span id="cb5-23"><a href="#cb5-23"></a></span>
<span id="cb5-24"><a href="#cb5-24"></a><span class="dt">bool</span> example_do_stuff_int(ffi_example* object, <span class="dt">int</span> arg) {</span>
<span id="cb5-25"><a href="#cb5-25"></a>  <span class="kw">auto</span> example = <span class="kw">reinterpret_cast</span>&lt;Example*&gt;(object);</span>
<span id="cb5-26"><a href="#cb5-26"></a>  <span class="cf">return</span> example-&gt;do_stuff(arg);  <span class="co">// calls the overload with int argument</span></span>
<span id="cb5-27"><a href="#cb5-27"></a>}</span>
<span id="cb5-28"><a href="#cb5-28"></a></span>
<span id="cb5-29"><a href="#cb5-29"></a><span class="dt">bool</span> example_do_stuff_float(ffi_example* object, <span class="dt">float</span> arg) {</span>
<span id="cb5-30"><a href="#cb5-30"></a>  <span class="kw">auto</span> example = <span class="kw">reinterpret_cast</span>&lt;Example*&gt;(object);</span>
<span id="cb5-31"><a href="#cb5-31"></a>  <span class="cf">return</span> example-&gt;do_stuff(arg);  <span class="co">// calls the overload with float argument</span></span>
<span id="cb5-32"><a href="#cb5-32"></a>}</span>
<span id="cb5-33"><a href="#cb5-33"></a></span>
<span id="cb5-34"><a href="#cb5-34"></a>}</span></code></pre></div>
<p>Finally, each variant has to be imported on the Haskell side:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="co">-- Rest of code is same as before.</span></span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a>foreign <span class="kw">import</span> ccall unsafe &quot;example_do_stuff_int&quot; exampleDoStuffInt</span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="ot">  ::</span> <span class="dt">Ptr</span> <span class="dt">Example</span> <span class="ot">-&gt;</span> <span class="dt">CInt</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">CBool</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>foreign <span class="kw">import</span> ccall unsafe &quot;example_do_stuff_float&quot; exampleDoStuffFloat</span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="ot">  ::</span> <span class="dt">Ptr</span> <span class="dt">Example</span> <span class="ot">-&gt;</span> <span class="dt">CFloat</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">CBool</span></span></code></pre></div>
<h3 id="loops">Loops</h3>
<p>So far we focused on a single object or data type, but what about multiple objects? In C++ for- or while-loops are used to iterate over collections of data. Loops, like the other concepts mentioned before, will require some massaging into a different format until we have something that can be used from the FFI.</p>
<p>Let's update our previous example to have a collection of some sort:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">class</span> Example {</span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="kw">private</span>:</span>
<span id="cb7-3"><a href="#cb7-3"></a>  <span class="co">// Example now contains a collection of data</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>  <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; values;</span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="kw">public</span>:</span>
<span id="cb7-7"><a href="#cb7-7"></a>  <span class="co">// To keep things simple, we initialize the vector to</span></span>
<span id="cb7-8"><a href="#cb7-8"></a>  <span class="co">// a collection of 3 hardcoded values.</span></span>
<span id="cb7-9"><a href="#cb7-9"></a>  Example() : values({<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>}) {}</span>
<span id="cb7-10"><a href="#cb7-10"></a></span>
<span id="cb7-11"><a href="#cb7-11"></a>  <span class="kw">auto</span>&amp; get_values() <span class="at">const</span> {</span>
<span id="cb7-12"><a href="#cb7-12"></a>      <span class="cf">return</span> values;</span>
<span id="cb7-13"><a href="#cb7-13"></a>  }</span>
<span id="cb7-14"><a href="#cb7-14"></a>};</span>
<span id="cb7-15"><a href="#cb7-15"></a></span>
<span id="cb7-16"><a href="#cb7-16"></a></span>
<span id="cb7-17"><a href="#cb7-17"></a><span class="co">// We can now loop over the data:</span></span>
<span id="cb7-18"><a href="#cb7-18"></a></span>
<span id="cb7-19"><a href="#cb7-19"></a>Example example;</span>
<span id="cb7-20"><a href="#cb7-20"></a><span class="kw">auto</span>&amp; values = example.get_values();</span>
<span id="cb7-21"><a href="#cb7-21"></a></span>
<span id="cb7-22"><a href="#cb7-22"></a><span class="cf">for</span> (<span class="kw">auto</span>&amp; value : values) {</span>
<span id="cb7-23"><a href="#cb7-23"></a>  process_value(value);</span>
<span id="cb7-24"><a href="#cb7-24"></a>}</span></code></pre></div>
<p>The example makes use of a range-based for-loop, which was introduced in C++11. Range-based loops are a form of syntactic sugar and can be rewritten using C++ iterators as follows:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="co">// Note: &quot;it&quot; is short for iterator</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="cf">for</span> (<span class="kw">auto</span> it = values.begin(); it != values.end(); ++it) {</span>
<span id="cb8-3"><a href="#cb8-3"></a>  <span class="kw">auto</span>&amp; value = *it;</span>
<span id="cb8-4"><a href="#cb8-4"></a>  process_value(value);</span>
<span id="cb8-5"><a href="#cb8-5"></a>}</span></code></pre></div>
<p>While we're at it, a standard for-loop is also sugar for a while-loop. Let's do another transform:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">auto</span> it = values.begin();</span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="cf">while</span> (it != values.end()) {</span>
<span id="cb9-3"><a href="#cb9-3"></a>  <span class="kw">auto</span>&amp; value = *it;</span>
<span id="cb9-4"><a href="#cb9-4"></a>  process_value(value);</span>
<span id="cb9-5"><a href="#cb9-5"></a>  ++it;</span>
<span id="cb9-6"><a href="#cb9-6"></a>}</span></code></pre></div>
<p>This is starting to come close to something that we can use from the FFI, we only need to write some functions for calling each of the steps of the loop separately:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">auto</span> it = ffi_iterator_create(values);</span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="cf">while</span> (ffi_iterator_has_next(it)) {</span>
<span id="cb10-3"><a href="#cb10-3"></a>  <span class="kw">auto</span>&amp; value = ffi_iterator_next(it);</span>
<span id="cb10-4"><a href="#cb10-4"></a>  <span class="bu">std::</span>cout &lt;&lt; value &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb10-5"><a href="#cb10-5"></a>}</span>
<span id="cb10-6"><a href="#cb10-6"></a>ffi_iterator_destroy(it);</span></code></pre></div>
<p>Writing each of the helper functions is quite a bit of work, but is based on ideas mentioned earlier in this blogpost:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="co">// in ffi.h</span></span>
<span id="cb11-2"><a href="#cb11-2"></a></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="kw">struct</span> ffi_iterator;  <span class="co">// New struct for iterating over the collection.</span></span>
<span id="cb11-4"><a href="#cb11-4"></a></span>
<span id="cb11-5"><a href="#cb11-5"></a>ffi_iterator* ffi_iterator_create(ffi_example* obj);</span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="dt">void</span> ffi_iterator_destroy(ffi_iterator* it);</span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="dt">bool</span> ffi_iterator_has_next(ffi_iterator* it);</span>
<span id="cb11-8"><a href="#cb11-8"></a><span class="dt">int</span> ffi_iterator_next(ffi_iterator* it);</span>
<span id="cb11-9"><a href="#cb11-9"></a></span>
<span id="cb11-10"><a href="#cb11-10"></a></span>
<span id="cb11-11"><a href="#cb11-11"></a><span class="co">// in ffi.cpp</span></span>
<span id="cb11-12"><a href="#cb11-12"></a></span>
<span id="cb11-13"><a href="#cb11-13"></a><span class="kw">struct</span> ffi_iterator {</span>
<span id="cb11-14"><a href="#cb11-14"></a>  <span class="kw">using</span> <span class="dt">iterator_t</span> = <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;::iterator;</span>
<span id="cb11-15"><a href="#cb11-15"></a></span>
<span id="cb11-16"><a href="#cb11-16"></a>  <span class="co">// We need to keep track of what the iterator is currently pointing to,</span></span>
<span id="cb11-17"><a href="#cb11-17"></a>  <span class="co">// as well as the end of the collection.</span></span>
<span id="cb11-18"><a href="#cb11-18"></a>  <span class="dt">iterator_t</span> iterator;</span>
<span id="cb11-19"><a href="#cb11-19"></a>  <span class="at">const</span> <span class="dt">iterator_t</span> end;</span>
<span id="cb11-20"><a href="#cb11-20"></a></span>
<span id="cb11-21"><a href="#cb11-21"></a>  ffi_iterator(<span class="at">const</span> <span class="dt">iterator_t</span>&amp; <span class="va">begin_</span>, <span class="at">const</span> <span class="dt">iterator_t</span>&amp; <span class="va">end_</span>)</span>
<span id="cb11-22"><a href="#cb11-22"></a>    : iterator(<span class="va">begin_</span>)</span>
<span id="cb11-23"><a href="#cb11-23"></a>    , end(<span class="va">end_</span>) {}</span>
<span id="cb11-24"><a href="#cb11-24"></a>};</span>
<span id="cb11-25"><a href="#cb11-25"></a></span>
<span id="cb11-26"><a href="#cb11-26"></a>ffi_iterator* ffi_iterator_create(ffi_example* obj) {</span>
<span id="cb11-27"><a href="#cb11-27"></a>  <span class="co">// We get the collection out of the object,</span></span>
<span id="cb11-28"><a href="#cb11-28"></a>  <span class="co">// and get the iterators pointing to beginning and end.</span></span>
<span id="cb11-29"><a href="#cb11-29"></a>  <span class="kw">auto</span> example = <span class="kw">reinterpret_cast</span>&lt;Example*&gt;(obj);</span>
<span id="cb11-30"><a href="#cb11-30"></a>  <span class="kw">auto</span>&amp; values = example.get_values();</span>
<span id="cb11-31"><a href="#cb11-31"></a>  <span class="cf">return</span> <span class="kw">new</span> ffi_iterator(values.begin(), values.end());</span>
<span id="cb11-32"><a href="#cb11-32"></a>}</span>
<span id="cb11-33"><a href="#cb11-33"></a></span>
<span id="cb11-34"><a href="#cb11-34"></a><span class="dt">void</span> ffi_iterator_destroy(ffi_iterator* it) {</span>
<span id="cb11-35"><a href="#cb11-35"></a>  <span class="kw">delete</span> it;</span>
<span id="cb11-36"><a href="#cb11-36"></a>}</span>
<span id="cb11-37"><a href="#cb11-37"></a></span>
<span id="cb11-38"><a href="#cb11-38"></a><span class="dt">bool</span> ffi_iterator_has_next(ffi_iterator* it) {</span>
<span id="cb11-39"><a href="#cb11-39"></a>  <span class="co">// There is a next value if the iterator is not pointing to the end.</span></span>
<span id="cb11-40"><a href="#cb11-40"></a>  <span class="cf">return</span> it-&gt;iterator != it-&gt;end;</span>
<span id="cb11-41"><a href="#cb11-41"></a>}</span>
<span id="cb11-42"><a href="#cb11-42"></a></span>
<span id="cb11-43"><a href="#cb11-43"></a><span class="dt">int</span> ffi_iterator_next(ffi_iterator* it) {</span>
<span id="cb11-44"><a href="#cb11-44"></a>  <span class="co">// Get the current element, then update iterator to next element.</span></span>
<span id="cb11-45"><a href="#cb11-45"></a>  <span class="kw">auto</span>&amp; value = *it-&gt;iterator;</span>
<span id="cb11-46"><a href="#cb11-46"></a>  ++it-&gt;iterator;</span>
<span id="cb11-47"><a href="#cb11-47"></a>  <span class="cf">return</span> value;</span>
<span id="cb11-48"><a href="#cb11-48"></a>}</span></code></pre></div>
<p>Once we have these functions, we can build our own loop in Haskell and process the values there:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">data</span> <span class="dt">ExampleIterator</span></span>
<span id="cb12-2"><a href="#cb12-2"></a></span>
<span id="cb12-3"><a href="#cb12-3"></a>foreign <span class="kw">import</span> ccall unsafe &quot;ffi_iterator_create&quot; ffiIteratorCreate</span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="ot">  ::</span> <span class="dt">Ptr</span> <span class="dt">Example</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Ptr</span> <span class="dt">ExampleIterator</span>)</span>
<span id="cb12-5"><a href="#cb12-5"></a>foreign <span class="kw">import</span> ccall unsafe &quot;&amp;ffi_iterator_destroy&quot; ffiIteratorDestroy</span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="ot">  ::</span> <span class="dt">FunPtr</span> (<span class="dt">Ptr</span> <span class="dt">ExampleIterator</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ())</span>
<span id="cb12-7"><a href="#cb12-7"></a>foreign <span class="kw">import</span> ccall unsafe &quot;ffi_iterator_has_next&quot; ffiIteratorHasNext</span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="ot">  ::</span> <span class="dt">Ptr</span> <span class="dt">ExampleIterator</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">CBool</span></span>
<span id="cb12-9"><a href="#cb12-9"></a>foreign <span class="kw">import</span> ccall unsafe &quot;ffi_iterator_next&quot; ffiIteratorNext</span>
<span id="cb12-10"><a href="#cb12-10"></a><span class="ot">  ::</span> <span class="dt">Ptr</span> <span class="dt">ExampleIterator</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">CInt</span></span>
<span id="cb12-11"><a href="#cb12-11"></a></span>
<span id="cb12-12"><a href="#cb12-12"></a></span>
<span id="cb12-13"><a href="#cb12-13"></a><span class="ot">mkExampleIterator ::</span> <span class="dt">Ptr</span> <span class="dt">Example</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">ForeignPtr</span> <span class="dt">ExampleIterator</span>)</span>
<span id="cb12-14"><a href="#cb12-14"></a>mkExampleIterator ptr <span class="ot">=</span></span>
<span id="cb12-15"><a href="#cb12-15"></a>  mask_ <span class="op">$</span> newForeignPtr ffiIteratorDestroy <span class="op">=&lt;&lt;</span> ffiIteratorCreate ptr</span>
<span id="cb12-16"><a href="#cb12-16"></a></span>
<span id="cb12-17"><a href="#cb12-17"></a><span class="co">-- Helper function for looping over the data and collecting the results on</span></span>
<span id="cb12-18"><a href="#cb12-18"></a><span class="co">-- the Haskell side.</span></span>
<span id="cb12-19"><a href="#cb12-19"></a><span class="ot">collectValues ::</span> <span class="dt">Ptr</span> <span class="dt">ExampleIterator</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">CInt</span>]</span>
<span id="cb12-20"><a href="#cb12-20"></a>collectValues <span class="ot">=</span> go [] <span class="kw">where</span></span>
<span id="cb12-21"><a href="#cb12-21"></a>  go acc iterator <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-22"><a href="#cb12-22"></a>    <span class="dt">CBool</span> hasNext <span class="ot">&lt;-</span> ffiIteratorHasNext iterator</span>
<span id="cb12-23"><a href="#cb12-23"></a>    <span class="kw">if</span> hasNext <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb12-24"><a href="#cb12-24"></a>      <span class="kw">then</span> <span class="kw">do</span></span>
<span id="cb12-25"><a href="#cb12-25"></a>        value <span class="ot">&lt;-</span> ffiIteratorNext iterator</span>
<span id="cb12-26"><a href="#cb12-26"></a>        go (value <span class="op">:</span> acc) iterator</span>
<span id="cb12-27"><a href="#cb12-27"></a>      <span class="kw">else</span> <span class="fu">pure</span> acc</span>
<span id="cb12-28"><a href="#cb12-28"></a></span>
<span id="cb12-29"><a href="#cb12-29"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb12-30"><a href="#cb12-30"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-31"><a href="#cb12-31"></a>  obj <span class="ot">&lt;-</span> mkExample</span>
<span id="cb12-32"><a href="#cb12-32"></a>  withForeignPtr obj <span class="op">$</span> \objPtr <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-33"><a href="#cb12-33"></a>    iterator <span class="ot">&lt;-</span> mkExampleIterator objPtr</span>
<span id="cb12-34"><a href="#cb12-34"></a>    withForeignPtr iterator <span class="op">$</span> \iteratorPtr <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-35"><a href="#cb12-35"></a>      values <span class="ot">&lt;-</span> collectValues iteratorPtr</span>
<span id="cb12-36"><a href="#cb12-36"></a>      <span class="co">-- Now you can process the values like you would</span></span>
<span id="cb12-37"><a href="#cb12-37"></a>      <span class="co">-- for any other Haskell value.</span></span>
<span id="cb12-38"><a href="#cb12-38"></a>      <span class="fu">print</span> <span class="op">$</span> <span class="fu">map</span> (<span class="op">+</span><span class="dv">1</span>) values</span></code></pre></div>
<h3 id="compiler-flags">Compiler flags</h3>
<p>That's it for the code part, but we're not finished quite yet! Because we are using 2 languages, we need to provide compilation flags for both Haskell and C++. This can be done in your project's package.yaml / cabal file / stack.yaml.</p>
<p>For example, in the souffle-haskell library, the package.yaml contains additional configuration instructing the C++ compiler to look for files in the <em>cbits</em> directory and use the given C++ compiler flags:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb13-1"><a href="#cb13-1"></a><span class="fu">cxx-sources</span><span class="kw">:</span><span class="at"> cbits/*.cpp</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="fu">include-dirs</span><span class="kw">:</span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="at">  </span><span class="kw">-</span><span class="at"> cbits</span></span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="at">  </span><span class="kw">-</span><span class="at"> cbits/souffle</span></span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="fu">cxx-options</span><span class="kw">:</span></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="at">  </span><span class="kw">-</span><span class="at"> -std=c++17</span></span>
<span id="cb13-7"><a href="#cb13-7"></a><span class="co">  # Provide other C++ compilation flags here as necessary.</span></span></code></pre></div>
<p>Note that you should not use <em>cpp-options</em> in the yaml file. This refers to the Haskell C-preprocessor config and does not refer to C++-options like I initially assumed.</p>
<p>Depending on the C++ code you are binding to, you may also need to add specific compiler flags for certain C++ compilers or operating systems. In package.yaml this can be done as follows:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb14-1"><a href="#cb14-1"></a><span class="fu">when</span><span class="kw">:</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="at">  </span><span class="kw">-</span><span class="at"> </span><span class="fu">condition</span><span class="kw">:</span><span class="at"> os(darwin)</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="at">    </span><span class="fu">extra-libraries</span><span class="kw">:</span><span class="at"> c++</span></span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>This post turned out <em>much</em> larger than I initially expected! I guess this shows that binding to C++ is more work than C, but can definitely be done. The code in some snippets is simplified to avoid making this blog post even longer. If you are interested in what a "real" example of this approach looks like, check out my <a href="https://github.com/luc-tielen/souffle-haskell">souffle-haskell library</a>. You can find the most relevant files for binding to C++ <a href="https://github.com/luc-tielen/souffle-haskell/blob/master/cbits/souffle.cpp">here</a>, <a href="https://github.com/luc-tielen/souffle-haskell/blob/master/lib/Language/Souffle/Internal/Bindings.hs">here</a> and <a href="https://github.com/luc-tielen/souffle-haskell/blob/master/lib/Language/Souffle/Internal.hs">here</a>.</p>
<p>One final thing to mention is that this approach isn't specific to Haskell, you would only need to swap out the Haskell code with your language of choice to bind to the underlying C++ code.</p>
<p>If you are interested in more content like this, follow me on <a href="https://twitter.com/luctielen">Twitter</a> for blogpost updates or subscribe to the <a href="https://luctielen.com/atom.xml">RSS feed</a>.</p>]]></content>
  </entry>
  <entry>
      <title>How to set up your blog with Haskell, Slick and Netlify</title>
      <link href="https://luctielen.com/posts/how_to_setup_blog_with_haskell_slick_and_netlify"/>
      <id>https://luctielen.com/posts/how_to_setup_blog_with_haskell_slick_and_netlify</id>
      <updated></updated>
      <category term="haskell"/>
      <category term="meta"/>
      <summary></summary>
      <content type="html"><![CDATA[<p>I wanted to setup a blog powered by Haskell and HTML/CSS and host it on Netlify. Creating a static site is easy enough using <em>Slick</em>, but this has no direct support for Netlify. In this first post I will show you how to fix that.</p>
<h2 id="tech-stack">Tech stack</h2>
<p>I wanted my blog to be easy to setup, minimal and extensible. In the past I've tried (and failed) setting up a blog because I never managed to finish the initial setup due to a complicated setup. After some googling around, I came across the <a href="https://hackage.haskell.org/package/slick">Slick static site generator</a>. Slick is written in Haskell and uses Pandoc + the Shake build system to compile all files into a static site. Slick assumes some Haskell knowledge but with the documentation you can have a first version of your blog up and running in a few minutes if you use the <a href="https://github.com/ChrisPenner/slick-template">default project template</a>.</p>
<p>After I got the blog up and running, it was time to give the website it's own look and feel. I started with a standalone HTML and CSS file and played around with the styling. Once I was happy with how the site looked, I replaced the templates and CSS that Slick provides by default with my own. The code for this blog can be found on <a href="https://github.com/luc-tielen/blog.git">Github</a>. The "site/" directory contains all templates / CSS / markdown used to generate this blog.</p>
<p>Generating the blog is as simple as running the following command:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1"></a>$ <span class="ex">stack</span> run</span></code></pre></div>
<p>This will put the generated files in the output folder you configured in "app/Main.hs".</p>
<h2 id="deploying-the-site">Deploying the site</h2>
<p>Now that I had the blog up and running, I still needed to deploy it somewhere. For this, I chose Netlify since it is often used for hosting static sites. Unfortunately though, Netlify has no direct support for Slick! To solve this, I wrote a small bash script that builds the blog and commits all necessary files from the blog into a separate orphan branch named "deploy":</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">#!/bin/bash</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="co"># Run this script locally to trigger a build and deploy.</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="co"># It assumes the &quot;deploy&quot; branch already exists</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co"># (create with &quot;git checkout --orphan deploy&quot;)</span></span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="kw">set</span> <span class="ex">-e</span></span>
<span id="cb2-8"><a href="#cb2-8"></a></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="bu">echo</span> <span class="st">&quot;Generating blog...&quot;</span></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="ex">stack</span> run</span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="fu">tar</span> czf build.tar.gz build/</span>
<span id="cb2-12"><a href="#cb2-12"></a></span>
<span id="cb2-13"><a href="#cb2-13"></a><span class="bu">echo</span> <span class="st">&quot;Updating blog content...&quot;</span></span>
<span id="cb2-14"><a href="#cb2-14"></a><span class="fu">git</span> checkout deploy</span>
<span id="cb2-15"><a href="#cb2-15"></a><span class="fu">rm</span> -rf build/</span>
<span id="cb2-16"><a href="#cb2-16"></a><span class="fu">tar</span> xzf build.tar.gz</span>
<span id="cb2-17"><a href="#cb2-17"></a><span class="fu">rm</span> build.tar.gz</span>
<span id="cb2-18"><a href="#cb2-18"></a></span>
<span id="cb2-19"><a href="#cb2-19"></a><span class="bu">echo</span> <span class="st">&quot;Deploying blog...&quot;</span></span>
<span id="cb2-20"><a href="#cb2-20"></a><span class="fu">git</span> add build/</span>
<span id="cb2-21"><a href="#cb2-21"></a><span class="fu">git</span> commit -m <span class="st">&#39;Deploy new version&#39;</span></span>
<span id="cb2-22"><a href="#cb2-22"></a><span class="fu">git</span> push</span>
<span id="cb2-23"><a href="#cb2-23"></a></span>
<span id="cb2-24"><a href="#cb2-24"></a><span class="fu">git</span> checkout -</span>
<span id="cb2-25"><a href="#cb2-25"></a></span>
<span id="cb2-26"><a href="#cb2-26"></a><span class="bu">exit</span> 0</span></code></pre></div>
<p>On the Netlify side, I configured it to trigger a deploy of the blog if a push was made to the "deploy" branch.</p>
<p>Last step was buying the domain name and linking it to my netlify app. I would suggest to buy the domain name via Netlify as well, for the easiest setup. For more information, see the <a href="https://docs.netlify.com/domains-https/custom-domains/#assign-a-domain-to-a-site">official Netlify docs</a>.</p>
<h2 id="whats-next">What's next?</h2>
<p>Phew, that was the first blogpost! If you followed along, you should now have your own blog setup! All that's left is to write some blogposts. <span class="emoji" data-emoji="smile">ðŸ˜„</span></p>
<p>So what can you expect on this blog in the future? Most content will be related to functional programming, compilers and logic, with maybe occassionally some other (non-)tech things. You can get updates on this blog if you follow me on <a href="https://twitter.com/luctielen">Twitter</a> or if you subscribe to my <a href="https://luctielen.com/atom.xml">RSS feed</a>.</p>
<p>Stay tuned!</p>]]></content>
  </entry>
</feed>
