<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="description" content="FP -&gt; Compilers -&gt; Logic -&gt; Blog">
    <meta name="author" content="Luc Tielen">
    <meta name=viewport content="width=device-width, initial-scale=1">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@luctielen">
<meta name="twitter:creator" content="@luctielen">
<meta name="twitter:title" content="Write your GDB scripts in Haskell">
    <meta name="twitter:description" content="">
    <meta name="twitter:image" content="https://luctielen.com/images/gdb-scripts-in-haskell.png">
    <title>Write your GDB scripts in Haskell</title>
    <link rel="icon" type="image/png" href="/images/favicon.png">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Amaranth&family=Titillium+Web&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">
  </head>
</head>
<body>
  <header>
    <nav>
      <a href="/">Blog</a>
      <a href="/videos">Videos</a>
      <a href="/about">About</a>
      <div class="social">
        <a href="https://twitter.com/luctielen">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 16 16"
          width="16"
          height="16"
        >
          <path
            d="M16 3.538a6.461 6.461 0 01-1.884.516 3.301 3.301 0 001.444-1.816 6.607 6.607 0 01-2.084.797 3.28 3.28 0 00-2.397-1.034 3.28 3.28 0 00-3.197 4.028 9.321 9.321 0 01-6.766-3.431 3.284 3.284 0 001.015 4.381A3.301 3.301 0 01.643 6.57v.041A3.283 3.283 0 003.277 9.83a3.291 3.291 0 01-1.485.057 3.293 3.293 0 003.066 2.281 6.586 6.586 0 01-4.862 1.359 9.286 9.286 0 005.034 1.475c6.037 0 9.341-5.003 9.341-9.341 0-.144-.003-.284-.009-.425a6.59 6.59 0 001.637-1.697z"
          />
        </svg>
      </a>
       
      <a href="https://github.com/luc-tielen">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 16 16"
          width="16"
          height="16"
        >
          <path
            d="M8 .198a8 8 0 00-2.529 15.591c.4.074.547-.174.547-.385 0-.191-.008-.821-.011-1.489-2.226.484-2.695-.944-2.695-.944-.364-.925-.888-1.171-.888-1.171-.726-.497.055-.486.055-.486.803.056 1.226.824 1.226.824.714 1.223 1.872.869 2.328.665.072-.517.279-.87.508-1.07-1.777-.202-3.645-.888-3.645-3.954 0-.873.313-1.587.824-2.147-.083-.202-.357-1.015.077-2.117 0 0 .672-.215 2.201.82A7.672 7.672 0 018 4.066c.68.003 1.365.092 2.004.269 1.527-1.035 2.198-.82 2.198-.82.435 1.102.162 1.916.079 2.117.513.56.823 1.274.823 2.147 0 3.073-1.872 3.749-3.653 3.947.287.248.543.735.543 1.481 0 1.07-.009 1.932-.009 2.195 0 .213.144.462.55.384A8 8 0 008.001.196z"
          />
        </svg>
      </a>
       
      <a href="https://www.youtube.com/channel/UCeMz1NwTQlkhQvIFYMZoAJQ">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
        >
          <path
            d="M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z"
          />
        </svg>
      </a>
      <a href="/atom.xml">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 16 16"
            width="16"
            height="16"
          >
            <path
              d="M2.13 11.733c-1.175 0-2.13.958-2.13 2.126 0 1.174.955 2.122 2.13 2.122a2.126 2.126 0 002.133-2.122 2.133 2.133 0 00-2.133-2.126zM.002 5.436v3.067c1.997 0 3.874.781 5.288 2.196a7.45 7.45 0 012.192 5.302h3.08c0-5.825-4.739-10.564-10.56-10.564zM.006 0v3.068C7.128 3.068 12.924 8.87 12.924 16H16C16 7.18 8.824 0 .006 0z"
            />
          </svg>
        </a>
      </div>
    </nav>
  </header>
  <main class="post">
    <h1>Write your GDB scripts in Haskell</h1>
    <!--
    <span class="date"></span>
    -->
    <div class="tags">
      <span class="tag tag-c++"><a href="/tag/c++">c++</a></span>
      <span class="tag tag-debugging"><a href="/tag/debugging">debugging</a></span>
      <span class="tag tag-haskell"><a href="/tag/haskell">haskell</a></span>
    </div>
    <img class="post-image" src="/images/gdb-scripts-in-haskell.png"/>
    <p>In this post, I will show how you can use the new <a href="https://github.com/luc-tielen/debugger-hs.git">debugger-hs</a> library in Haskell to generate GDB scripts.</p>
<h2 id="debugging-in-gdb">Debugging in GDB</h2>
<p>Recently, I had to do lots of debugging in a C++ codebase using GDB at $DAY_JOB. While it is possible to start debugging by placing some breakpoints yourself for simple pieces of code, this quickly turns into a lot of manual and repetitive work for complex debugging sessions.</p>
<p>Thankfully, GDB allows you to script all these actions. A GDB script is a list of statements, and is executed from top to bottom. Here's an example of such script:</p>
<pre class="gdb"><code># This sets a breakpoint at line 8 in main.cpp
break main.cpp:8

# Breakpoints are numbered, starting from 1
# We can attach automatic actions to a breakpoint using &quot;command&quot; statement:
command 1
  # The next line prints the current value of the &quot;x&quot; variable
  print x
  # And then continue the program like normal (until next breakpoint)
  continue
end</code></pre>
<p>If we run this script on the following C++ code, it would print out all values of x that are passed into the function <code>f</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1"></a><span class="dt">void</span> f(<span class="dt">int</span> x) {</span>
<span id="cb2-2"><a href="#cb2-2"></a>  <span class="co">// ...</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>}</span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>** argv) {</span>
<span id="cb2-6"><a href="#cb2-6"></a>  <span class="cf">for</span> (<span class="dt">int</span> x = <span class="dv">0</span>; x &lt; <span class="dv">100</span>; ++x) {</span>
<span id="cb2-7"><a href="#cb2-7"></a>    <span class="cf">if</span> (x % <span class="dv">10</span> == <span class="dv">0</span>) {</span>
<span id="cb2-8"><a href="#cb2-8"></a>      f(x);</span>
<span id="cb2-9"><a href="#cb2-9"></a>    }</span>
<span id="cb2-10"><a href="#cb2-10"></a>  }</span>
<span id="cb2-11"><a href="#cb2-11"></a>  <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb2-12"><a href="#cb2-12"></a>}</span></code></pre></div>
<h2 id="debugging-using-haskell">Debugging using Haskell</h2>
<p>GDB scripts already are a big improvement over manually typing in commands each time, but I still felt many things to be less than ideal:</p>
<ol>
<li>The scripting language in GDB doesn't always work as expected. For example, some GDB commands that normally print information to the screen do not print a value inside a user-defined function!</li>
<li>Setting breakpoints and handling them is a 2-step process.</li>
<li>There is no typesystem like in Haskell, issues in scripts are detected only when the line in the script is triggered. The resulting errors can also be <em>very</em> confusing.</li>
</ol>
<p>Instead of trying to keep track of all these oddities, I set out to write a library that tackles these issues. Here's what the same GDB script from before looks like using <code>debugger-hs</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">-- GDB scripts are constructed using a builder-pattern</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="ot">script ::</span> <span class="dt">Builder</span> ()</span>
<span id="cb3-3"><a href="#cb3-3"></a>script <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>  <span class="co">-- Setting a breakpoint returns the corresponding breakpoint id</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>  bp <span class="ot">&lt;-</span> <span class="fu">break</span> (<span class="dt">File</span> <span class="st">&quot;main.cpp&quot;</span> <span class="dv">8</span>)</span>
<span id="cb3-6"><a href="#cb3-6"></a></span>
<span id="cb3-7"><a href="#cb3-7"></a>  command bp <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>    <span class="fu">print</span> <span class="st">&quot;x&quot;</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>    continue</span>
<span id="cb3-10"><a href="#cb3-10"></a></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb3-12"><a href="#cb3-12"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-13"><a href="#cb3-13"></a>  <span class="kw">let</span> gdbScript <span class="ot">=</span> runBuilder script</span>
<span id="cb3-14"><a href="#cb3-14"></a>  renderIO gdbScript <span class="st">&quot;./script.gdb&quot;</span></span></code></pre></div>
<p>As you can see, it looks similar to the original script thanks to do-syntax and the EDSL that <code>debugger-hs</code> provides. When the Haskell code is executed, a GDB script is generated and saved as "script.gdb":</p>
<pre class="gdb"><code>break main.cpp:8
set $var0 = $bpnum

command $var0
  print x
  continue
end</code></pre>
<p>The script has the same behavior as before, but you may notice there's an extra statement: <code>$var0</code> is set to <code>$bpnum</code>. <code>$bpnum</code> is a magic variable that GDB uses to always keep track of the last breakpoint id that was generated. By setting <code>$var0</code> to this value, it makes it possible in the Haskell DSL to always know the id of the last set breakpoint (since <code>$bpnum</code> keeps changing with each breakpoint). The library manages all this automatically, making it possible to build other abstractions on top (as we will see in the next section).</p>
<p>Another thing to note is that once the Haskell code finishes executing, the produced script no longer contains any Haskell and consists 100% of GDB statements. This avoids potential lock-in to the library and it might also make it easier to introduce Haskell into the workplace.</p>
<h2 id="a-more-complex-example">A more complex example</h2>
<p>One situation that I often ran into while debugging was that I had to check if certain places in the code were triggered sequentially in order. In GDB, you could do this with a script that looks as follows:</p>
<pre class="gdb"><code>break func1

command 1
    break func2

    command 2
        ...
    end

    continue
end</code></pre>
<p>While this works, it gets unwieldy very fast with the ever increasing indentation. I would much rather write code that handles the first breakpoint <em>and then</em> handle the later breakpoints. If you've been coding in Haskell for some time, you know where I'm going with this.. <span class="emoji" data-emoji="wink">😉</span></p>
<p>With <code>debugger-hs</code>, we can fix this problem by making good use of abstractions in Haskell. First we define a helper function that sets a breakpoint and then configures the actions that need to be run when the breakpoint is triggered:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="ot">withBreakpoint ::</span> <span class="dt">Location</span> <span class="ot">-&gt;</span> (<span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">Builder</span> ()) <span class="ot">-&gt;</span> <span class="dt">Builder</span> ()</span>
<span id="cb6-2"><a href="#cb6-2"></a>withBreakpoint loc f <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>  bp <span class="ot">&lt;-</span> <span class="fu">break</span> loc</span>
<span id="cb6-4"><a href="#cb6-4"></a>  command bp <span class="op">$</span> f bp</span></code></pre></div>
<p>With this helper function, we can now write code like this:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="ot">script ::</span> <span class="dt">Builder</span> ()</span>
<span id="cb7-2"><a href="#cb7-2"></a>script <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>  withBreakpoint (<span class="dt">Function</span> <span class="st">&quot;func1&quot;</span>) <span class="op">$</span> \bp1 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>    withBreakpoint (<span class="dt">Function</span> <span class="st">&quot;func2&quot;</span>) <span class="op">$</span> \bp2 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>      _  <span class="co">-- ...</span></span></code></pre></div>
<p>The indentation issue is still present, but our code is better factored now that the creation and processing of a breakpoint is handled in one place. But, we're not done yet. If you look closely, you'll see that we are making use of continuations now. This allows us to take the refactoring one step further using the continuation monad from <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Cont.html">Control.Monad.Cont</a>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="ot">script ::</span> <span class="dt">Builder</span> ()</span>
<span id="cb8-2"><a href="#cb8-2"></a>script <span class="ot">=</span> <span class="fu">flip</span> runContT handleResult <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>  bp1 <span class="ot">&lt;-</span> <span class="dt">ContT</span> <span class="op">$</span> withBreakpoint (<span class="dt">Function</span> <span class="st">&quot;func1&quot;</span>)</span>
<span id="cb8-4"><a href="#cb8-4"></a>  bp2 <span class="ot">&lt;-</span> <span class="dt">ContT</span> <span class="op">$</span> withBreakpoint (<span class="dt">Function</span> <span class="st">&quot;func2&quot;</span>)</span>
<span id="cb8-5"><a href="#cb8-5"></a>  <span class="co">-- ...</span></span>
<span id="cb8-6"><a href="#cb8-6"></a>  <span class="kw">where</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>    handleResult _ <span class="ot">=</span> <span class="fu">pure</span> ()</span></code></pre></div>
<p>The indentation is completely flat now and the code reads from top to bottom, which is more in-line with how the script actually runs.</p>
<p>In a more complex/realistic situation, we can now attach actions to each breakpoint by using <code>lift</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="ot">script ::</span> <span class="dt">Builder</span> ()</span>
<span id="cb9-2"><a href="#cb9-2"></a>script <span class="ot">=</span> <span class="fu">flip</span> runContT delete <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>  bp1 <span class="ot">&lt;-</span> <span class="dt">ContT</span> <span class="op">$</span> withBreakpoint (<span class="dt">Function</span> <span class="st">&quot;func1&quot;</span>)</span>
<span id="cb9-4"><a href="#cb9-4"></a>  lift <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb9-5"><a href="#cb9-5"></a>    <span class="co">-- ... actions to run for breakpoint 1</span></span>
<span id="cb9-6"><a href="#cb9-6"></a>    <span class="fu">print</span> <span class="st">&quot;x&quot;</span></span>
<span id="cb9-7"><a href="#cb9-7"></a>    <span class="fu">print</span> <span class="st">&quot;y&quot;</span></span>
<span id="cb9-8"><a href="#cb9-8"></a></span>
<span id="cb9-9"><a href="#cb9-9"></a>  bp2 <span class="ot">&lt;-</span> <span class="dt">ContT</span> <span class="op">$</span> withBreakpoint (<span class="dt">Function</span> <span class="st">&quot;func2&quot;</span>)</span>
<span id="cb9-10"><a href="#cb9-10"></a>  lift <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb9-11"><a href="#cb9-11"></a>    _  <span class="co">-- ... actions to run for breakpoint 2</span></span>
<span id="cb9-12"><a href="#cb9-12"></a></span>
<span id="cb9-13"><a href="#cb9-13"></a>  <span class="fu">pure</span> [bp1, bp2]</span></code></pre></div>
<p>This generates the GDB script below:</p>
<pre class="gdb"><code>break func1
set $var0 = $bpnum
command $var0
    # ... actions for breakpoint 1
    print x
    print y

    break func2
    set $var1 = $bpnum
    command $var1
        # ... actions for breakpoint 2

        delete $var0 $var1
    end
end</code></pre>
<p>Note also how the breakpoints are automatically cleaned up at the right location by passing in the <code>delete</code> function to <code>runContT</code>. This is another feature we got for free by making use of the continuation monad. Neat!</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this post I showed how we can make use of the new <a href="https://github.com/luc-tielen/debugger-hs.git">debugger-hs</a> library to create complex GDB scripts with little effort. The library is still in early stages, but it can already generate complex scripts thanks to Haskell's powerful abstraction capabilities and ecosystem. Some features I still plan to add to the library are LLDB support, increasing the coverage of GDB statements in the EDSL and improving the type safety in some places to prevent mistakes at compile time in Haskell.</p>
<p>If you need to use a debugger often and are unhappy with what GDB provides by default, give this library a shot and let me know on <a href="https://twitter.com/luctielen">Twitter</a> how it went!</p>
    <img src="https://api.stathat.com/c?ukey=MTk2NzAgWkL6UC1F__NJ8FQSQf0CiA~~&key=27ZUKzMSpTwf7JNpDPdlHiA0WVlO&count=1"
         style="display:none;" width="1" height="1"/>
  </main>
</body>
