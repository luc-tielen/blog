<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="description" content="FP -&gt; Compilers -&gt; Logic -&gt; Blog">
    <meta name="author" content="Luc Tielen">
    <meta name=viewport content="width=device-width, initial-scale=1">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@luctielen">
<meta name="twitter:creator" content="@luctielen">
<meta name="twitter:title" content="Static analysis using Haskell and Datalog">
    <meta name="twitter:description" content="">
    <meta name="twitter:image" content="https://luctielen.com/images/static_analysis_in_haskell_and_datalog.png">
    <title>Static analysis using Haskell and Datalog</title>
    <link rel="icon" type="image/png" href="/images/favicon.png">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Amaranth&family=Titillium+Web&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">
  </head>
</head>
<body>
  <header>
    <nav>
      <a href="/">Blog</a>
      <a href="/videos">Videos</a>
      <a href="/about">About</a>
      <div class="social">
        <a href="https://twitter.com/luctielen">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 16 16"
          width="16"
          height="16"
        >
          <path
            d="M16 3.538a6.461 6.461 0 01-1.884.516 3.301 3.301 0 001.444-1.816 6.607 6.607 0 01-2.084.797 3.28 3.28 0 00-2.397-1.034 3.28 3.28 0 00-3.197 4.028 9.321 9.321 0 01-6.766-3.431 3.284 3.284 0 001.015 4.381A3.301 3.301 0 01.643 6.57v.041A3.283 3.283 0 003.277 9.83a3.291 3.291 0 01-1.485.057 3.293 3.293 0 003.066 2.281 6.586 6.586 0 01-4.862 1.359 9.286 9.286 0 005.034 1.475c6.037 0 9.341-5.003 9.341-9.341 0-.144-.003-.284-.009-.425a6.59 6.59 0 001.637-1.697z"
          />
        </svg>
      </a>
       
      <a href="https://github.com/luc-tielen">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 16 16"
          width="16"
          height="16"
        >
          <path
            d="M8 .198a8 8 0 00-2.529 15.591c.4.074.547-.174.547-.385 0-.191-.008-.821-.011-1.489-2.226.484-2.695-.944-2.695-.944-.364-.925-.888-1.171-.888-1.171-.726-.497.055-.486.055-.486.803.056 1.226.824 1.226.824.714 1.223 1.872.869 2.328.665.072-.517.279-.87.508-1.07-1.777-.202-3.645-.888-3.645-3.954 0-.873.313-1.587.824-2.147-.083-.202-.357-1.015.077-2.117 0 0 .672-.215 2.201.82A7.672 7.672 0 018 4.066c.68.003 1.365.092 2.004.269 1.527-1.035 2.198-.82 2.198-.82.435 1.102.162 1.916.079 2.117.513.56.823 1.274.823 2.147 0 3.073-1.872 3.749-3.653 3.947.287.248.543.735.543 1.481 0 1.07-.009 1.932-.009 2.195 0 .213.144.462.55.384A8 8 0 008.001.196z"
          />
        </svg>
      </a>
       
      <a href="https://www.youtube.com/channel/UCeMz1NwTQlkhQvIFYMZoAJQ">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
        >
          <path
            d="M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z"
          />
        </svg>
      </a>
      <a href="/atom.xml">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 16 16"
            width="16"
            height="16"
          >
            <path
              d="M2.13 11.733c-1.175 0-2.13.958-2.13 2.126 0 1.174.955 2.122 2.13 2.122a2.126 2.126 0 002.133-2.122 2.133 2.133 0 00-2.133-2.126zM.002 5.436v3.067c1.997 0 3.874.781 5.288 2.196a7.45 7.45 0 012.192 5.302h3.08c0-5.825-4.739-10.564-10.56-10.564zM.006 0v3.068C7.128 3.068 12.924 8.87 12.924 16H16C16 7.18 8.824 0 .006 0z"
            />
          </svg>
        </a>
      </div>
    </nav>
  </header>
  <main class="post">
    <h1>Static analysis using Haskell and Datalog</h1>
    <!--
    <span class="date"></span>
    -->
    <div class="tags">
      <span class="tag tag-haskell"><a href="/tag/haskell">haskell</a></span>
      <span class="tag tag-datalog"><a href="/tag/datalog">datalog</a></span>
      <span class="tag tag-static analysis"><a href="/tag/static analysis">static analysis</a></span>
    </div>
    <img class="post-image" src="/images/static_analysis_in_haskell_and_datalog.png"/>
    <p>In today's post, I will give a step-by-step tutorial how you can write sophisticated analyses in Soufflé Datalog controlled by Haskell using the souffle-haskell library. In this article I will assume you've already read the <a href="https://github.com/luc-tielen/souffle-haskell">README</a> or watched this <a href="https://luctielen.com/videos/leverage_the_power_of_logic_programming/">talk</a> where I explain the basics of the library.</p>
<p>In this guide, I will use a name-shadowing analysis for a simple language as an example. The analysis is not that complicated, but it does allow me to showcase some of the more interesting aspects when mixing Datalog and Haskell.</p>
<h2 id="anatomy-of-an-analysis">Anatomy of an analysis</h2>
<p>If we look at an analysis from a bird's-eye view, it consists of a few steps:</p>
<ol>
<li>Determine what you want to analyze;</li>
<li>Decompose your analysis in terms of simple facts;</li>
<li>Traverse over your data, deducing simple facts along the way;</li>
<li>Compute derived facts in Datalog and process your data using the new-found results back in Haskell.</li>
</ol>
<p>In each of the following sections, we will go over each of these steps in more detail.</p>
<h3 id="find-something-to-analyze">Find something to analyze</h3>
<p>Before we can start writing an analysis, we will first need something that we can analyze! Here's a simple (though somewhat contrived) expression-based language that has support for scoped blocks of code and variable assignment:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">type</span> <span class="dt">Var</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">type</span> <span class="dt">Value</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>  <span class="ot">=</span> <span class="dt">Block</span> [<span class="dt">Expr</span>]</span>
<span id="cb1-7"><a href="#cb1-7"></a>  <span class="op">|</span> <span class="dt">Assign</span> <span class="dt">Var</span> <span class="dt">Value</span></span></code></pre></div>
<p>With this language, we can now create a small program:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">exampleExpr ::</span> <span class="dt">Expr</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>exampleExpr <span class="ot">=</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>  <span class="dt">Block</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>    [ <span class="dt">Assign</span> <span class="st">&quot;x&quot;</span> <span class="dv">123</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>    , <span class="dt">Block</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>      [ <span class="dt">Assign</span> <span class="st">&quot;x&quot;</span> <span class="dv">456</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>      ]</span>
<span id="cb2-8"><a href="#cb2-8"></a>    ]</span></code></pre></div>
<p>This corresponds with the following pseudo-code:</p>
<pre><code>{            // First scope starts here
  x = 123    //                                              &lt;─┐
  {          // Second scope starts here                       │
    x = 456  // Should give warning, shadows first assignment ─┘
  }
}</code></pre>
<p>With this language, you can also have another situation where a variable shadows a previously declared variable in the same scope:</p>
<pre><code>{
  x = 1  //                                  &lt;─┐
  x = 2  // Shadows variable on previous line ─┘
}</code></pre>
<p>I won't be going over the second case in detail (to keep the article from becoming too long), but you can solve it in a comparable way as the first example.</p>
<h3 id="decompose-analysis-in-terms-of-facts">Decompose analysis in terms of facts</h3>
<p>So how did I determine in the previous examples that a variable was shadowed? I made certain observations (facts) about the code and then combined these facts to form conclusions about the data. This is very close to how a logic programming language like Datalog works!</p>
<p>For name shadowing, what are the basic facts? First of all, we need to keep track of which variables are defined in the program. Secondly, another important fact that we can use is which scopes are nested inside each other.</p>
<p>In Datalog, we can write a query that uses these facts to check for name shadowing:</p>
<pre class="datalog"><code>// Declarations for the facts and relations used in our analysis:
.decl define(scope: symbol, variable: symbol)
.decl nested_scope(scope: symbol, sub_scope: symbol)
.decl shadowed(variable: symbol)

// All data coming from Haskell needs to be marked as inputs,
// the results of the analysis are marked as outputs.
.input define
.input nested_scope
.output shadowed

// Read this query as follows:
//
// A variable is shadowed iff:
// it is defined in a scope &#39;scope&#39;
// AND it is defined again in scope &#39;sub_scope&#39;
// AND &#39;sub_scope&#39; is a scope nested inside of &#39;scope&#39;.
shadowed(variable) :-
  define(scope, variable),
  define(sub_scope, variable),
  nested_scope(scope, sub_scope).</code></pre>
<p>That's all there is to it! As you can tell, the transformation from the logical description of the analysis to the actual Datalog code is quite straight-forward.</p>
<p>When creating your Datalog queries, you can either check for "positive" or "negative" scenarios. With positive scenarios, I mean Datalog queries that search which values match certain criteria. Negative scenarios on the other hand check if an error situation occurred (like in this example).</p>
<p>One final thing to note here is that in a more complete implementation the query would contain extra information (for example line numbers). This has some additional benefits:</p>
<ol>
<li>You can use the line numbers in your query results (e.g. compiler error messages).</li>
<li>You can check more things if you have more information (such as name shadowing in same scope).</li>
</ol>
<h3 id="deducing-facts-of-your-data">Deducing facts of your data</h3>
<p>Now that we have written our Datalog analysis (and saved it as <code>name_shadowing.dl</code>), we can start calling it from Haskell. For this we will need some code to bind to the corresponding Datalog code:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="co">-- A type for representing our Datalog program:</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="kw">data</span> <span class="dt">NameShadowing</span> <span class="ot">=</span> <span class="dt">NameShadowing</span></span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="co">-- Types that correspond with our Datalog facts:</span></span>
<span id="cb6-5"><a href="#cb6-5"></a></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="kw">type</span> <span class="dt">Scope</span> <span class="ot">=</span> <span class="dt">Int32</span></span>
<span id="cb6-7"><a href="#cb6-7"></a></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="kw">data</span> <span class="dt">Define</span> <span class="ot">=</span> <span class="dt">Define</span> <span class="dt">Scope</span> <span class="dt">Var</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>  <span class="kw">deriving</span> <span class="dt">Generic</span></span>
<span id="cb6-10"><a href="#cb6-10"></a></span>
<span id="cb6-11"><a href="#cb6-11"></a><span class="kw">data</span> <span class="dt">NestedScope</span></span>
<span id="cb6-12"><a href="#cb6-12"></a>  <span class="ot">=</span> <span class="dt">NestedScope</span></span>
<span id="cb6-13"><a href="#cb6-13"></a>  {<span class="ot"> _scope ::</span> <span class="dt">Scope</span></span>
<span id="cb6-14"><a href="#cb6-14"></a>  ,<span class="ot"> _subscope ::</span> <span class="dt">Scope</span></span>
<span id="cb6-15"><a href="#cb6-15"></a>  } <span class="kw">deriving</span> <span class="dt">Generic</span></span>
<span id="cb6-16"><a href="#cb6-16"></a></span>
<span id="cb6-17"><a href="#cb6-17"></a><span class="kw">data</span> <span class="dt">Shadowed</span> <span class="ot">=</span> <span class="dt">Shadowed</span> <span class="dt">Var</span></span>
<span id="cb6-18"><a href="#cb6-18"></a>  <span class="kw">deriving</span> (<span class="dt">Generic</span>, <span class="dt">Show</span>)</span>
<span id="cb6-19"><a href="#cb6-19"></a></span>
<span id="cb6-20"><a href="#cb6-20"></a><span class="co">-- Some instances for communicating between Haskell and Datalog:</span></span>
<span id="cb6-21"><a href="#cb6-21"></a></span>
<span id="cb6-22"><a href="#cb6-22"></a><span class="kw">instance</span> <span class="dt">S.Program</span> <span class="dt">NameShadowing</span> <span class="kw">where</span></span>
<span id="cb6-23"><a href="#cb6-23"></a>  <span class="kw">type</span> <span class="dt">ProgramFacts</span> <span class="dt">NameShadowing</span> <span class="ot">=</span> &#39;[<span class="dt">Shadowed</span>, <span class="dt">Define</span>, <span class="dt">NestedScope</span>]</span>
<span id="cb6-24"><a href="#cb6-24"></a>  programName <span class="ot">=</span> <span class="fu">const</span> <span class="st">&quot;name_shadowing&quot;</span></span>
<span id="cb6-25"><a href="#cb6-25"></a></span>
<span id="cb6-26"><a href="#cb6-26"></a><span class="kw">instance</span> <span class="dt">S.Fact</span> <span class="dt">Define</span> <span class="kw">where</span></span>
<span id="cb6-27"><a href="#cb6-27"></a>  <span class="kw">type</span> <span class="dt">FactDirection</span> <span class="dt">Define</span> <span class="ot">=</span> <span class="dt">&#39;S.Input</span></span>
<span id="cb6-28"><a href="#cb6-28"></a>  factName <span class="ot">=</span> <span class="fu">const</span> <span class="st">&quot;define&quot;</span></span>
<span id="cb6-29"><a href="#cb6-29"></a></span>
<span id="cb6-30"><a href="#cb6-30"></a><span class="kw">instance</span> <span class="dt">S.Fact</span> <span class="dt">NestedScope</span> <span class="kw">where</span></span>
<span id="cb6-31"><a href="#cb6-31"></a>  <span class="kw">type</span> <span class="dt">FactDirection</span> <span class="dt">NestedScope</span> <span class="ot">=</span> <span class="dt">&#39;S.Input</span></span>
<span id="cb6-32"><a href="#cb6-32"></a>  factName <span class="ot">=</span> <span class="fu">const</span> <span class="st">&quot;nested_scope&quot;</span></span>
<span id="cb6-33"><a href="#cb6-33"></a></span>
<span id="cb6-34"><a href="#cb6-34"></a><span class="kw">instance</span> <span class="dt">S.Fact</span> <span class="dt">Shadowed</span> <span class="kw">where</span></span>
<span id="cb6-35"><a href="#cb6-35"></a>  <span class="kw">type</span> <span class="dt">FactDirection</span> <span class="dt">Shadowed</span> <span class="ot">=</span> <span class="dt">&#39;S.Output</span></span>
<span id="cb6-36"><a href="#cb6-36"></a>  factName <span class="ot">=</span> <span class="fu">const</span> <span class="st">&quot;shadowed&quot;</span></span>
<span id="cb6-37"><a href="#cb6-37"></a></span>
<span id="cb6-38"><a href="#cb6-38"></a><span class="kw">instance</span> <span class="dt">S.Marshal</span> <span class="dt">Define</span></span>
<span id="cb6-39"><a href="#cb6-39"></a><span class="kw">instance</span> <span class="dt">S.Marshal</span> <span class="dt">NestedScope</span></span>
<span id="cb6-40"><a href="#cb6-40"></a><span class="kw">instance</span> <span class="dt">S.Marshal</span> <span class="dt">Shadowed</span></span></code></pre></div>
<p>This approach should look familiar if you've read the <a href="https://github.com/luc-tielen/souffle-haskell">souffle-haskell README</a>. Once we've written the binding code, we can write a function that traverses our data and deduces facts:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="ot">deduceFacts ::</span> <span class="dt">S.Handle</span> <span class="dt">NameShadowing</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">S.SouffleM</span> ()</span>
<span id="cb7-2"><a href="#cb7-2"></a>deduceFacts handle expr <span class="ot">=</span> runReaderT (go expr) rootScope</span>
<span id="cb7-3"><a href="#cb7-3"></a>  <span class="kw">where</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>    <span class="co">-- Our function needs to keep track of which scope it is in.</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>    <span class="co">-- Scope at root level is 0, every nested scope increases by 1.</span></span>
<span id="cb7-6"><a href="#cb7-6"></a>    <span class="co">-- We can use the Reader monad for keeping track of scope since</span></span>
<span id="cb7-7"><a href="#cb7-7"></a>    <span class="co">-- we only ever modify it locally and for the rest only</span></span>
<span id="cb7-8"><a href="#cb7-8"></a>    <span class="co">-- perform reads.</span></span>
<span id="cb7-9"><a href="#cb7-9"></a>    rootScope <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb7-10"><a href="#cb7-10"></a>    newScope s <span class="ot">=</span> s <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb7-11"><a href="#cb7-11"></a>    go expr <span class="ot">=</span> <span class="kw">case</span> expr <span class="kw">of</span></span>
<span id="cb7-12"><a href="#cb7-12"></a>      <span class="co">-- Assignments are simple: we lookup the current scope</span></span>
<span id="cb7-13"><a href="#cb7-13"></a>      <span class="co">-- and store the fact that a variable is defined at this scope.</span></span>
<span id="cb7-14"><a href="#cb7-14"></a>      <span class="dt">Assign</span> var _value <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb7-15"><a href="#cb7-15"></a>        currentScope <span class="ot">&lt;-</span> ask</span>
<span id="cb7-16"><a href="#cb7-16"></a>        S.addFact handle <span class="op">$</span> <span class="dt">Define</span> currentScope var</span>
<span id="cb7-17"><a href="#cb7-17"></a>      <span class="co">-- Blocks are more complicated since the scope changes when you</span></span>
<span id="cb7-18"><a href="#cb7-18"></a>      <span class="co">-- enter a block. We can use Reader here for easy access to the</span></span>
<span id="cb7-19"><a href="#cb7-19"></a>      <span class="co">-- scope info. If we are in a nested scope, then we can submit</span></span>
<span id="cb7-20"><a href="#cb7-20"></a>      <span class="co">-- this fact to Datalog as well.</span></span>
<span id="cb7-21"><a href="#cb7-21"></a>      <span class="dt">Block</span> exprs <span class="ot">-&gt;</span> local newScope <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb7-22"><a href="#cb7-22"></a>        currentScope <span class="ot">&lt;-</span> ask</span>
<span id="cb7-23"><a href="#cb7-23"></a>        when (currentScope <span class="op">&gt;</span> rootScope) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb7-24"><a href="#cb7-24"></a>          <span class="kw">let</span> prevScope <span class="ot">=</span> currentScope <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb7-25"><a href="#cb7-25"></a>          S.addFact handle <span class="op">$</span> <span class="dt">NestedScope</span> prevScope currentScope</span>
<span id="cb7-26"><a href="#cb7-26"></a>        <span class="co">-- Don&#39;t forget to handle the nested sub-expressions:</span></span>
<span id="cb7-27"><a href="#cb7-27"></a>        traverse_ go exprs</span></code></pre></div>
<p>Phew! That was a dense piece of code. Hopefully the comments in between helped reason about the code. As you can see, computing facts based on a single point of data is easy. If a fact is based on some context and it requires information about multiple places in the data, it gets a little more tricky. Here I used manual recursion and monads to solve this issue, but you are completely free to compute facts in any possible way based on the input data. (I haven't tried this out myself yet, but I have a feeling this might be a great fit for comonads..)</p>
<h3 id="processing-the-analysis-results">Processing the analysis results</h3>
<p>We are almost there! The final step is to run the analysis and use the computed results in the rest of your library or application code.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb8-2"><a href="#cb8-2"></a>main <span class="ot">=</span> S.runSouffle <span class="dt">NameShadowing</span> <span class="op">$</span> \<span class="kw">case</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span></span>
<span id="cb8-4"><a href="#cb8-4"></a>    liftIO <span class="op">$</span> <span class="fu">putStrLn</span> <span class="st">&quot;Failed to load program.&quot;</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>  <span class="dt">Just</span> prog <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb8-6"><a href="#cb8-6"></a>    deduceFacts prog exampleExpr</span>
<span id="cb8-7"><a href="#cb8-7"></a>    S.run prog</span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="ot">    shadowedVars ::</span> [<span class="dt">Shadowed</span>] <span class="ot">&lt;-</span> S.getFacts prog</span>
<span id="cb8-9"><a href="#cb8-9"></a>    <span class="co">-- Here we only print out the results, but you could</span></span>
<span id="cb8-10"><a href="#cb8-10"></a>    <span class="co">-- use the results for error reporting, optimizations, ...</span></span>
<span id="cb8-11"><a href="#cb8-11"></a>    liftIO <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb8-12"><a href="#cb8-12"></a>      <span class="fu">putStrLn</span> <span class="st">&quot;Shadowed variables in expression:&quot;</span></span>
<span id="cb8-13"><a href="#cb8-13"></a>      traverse_ <span class="fu">print</span> shadowedVars</span></code></pre></div>
<p>By the way, if you have multiple fact types you need to retrieve from Soufflé, you can make clever use of Haskell's typesystem to collect all these different facts with very little code:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">data</span> <span class="dt">Fact1</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="kw">data</span> <span class="dt">Fact2</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="kw">data</span> <span class="dt">Fact3</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="kw">data</span> <span class="dt">AnalysisResult</span> <span class="ot">=</span> <span class="dt">AnalysisResult</span> [<span class="dt">Fact1</span>] [<span class="dt">Fact2</span>] [<span class="dt">Fact3</span>]</span>
<span id="cb9-5"><a href="#cb9-5"></a></span>
<span id="cb9-6"><a href="#cb9-6"></a>main <span class="ot">=</span> runSouffle <span class="dt">MyAnalysis</span> <span class="op">$</span> \<span class="kw">case</span></span>
<span id="cb9-7"><a href="#cb9-7"></a>  <span class="dt">Just</span> prog <span class="ot">-&gt;</span></span>
<span id="cb9-8"><a href="#cb9-8"></a>    <span class="co">-- For each of the following calls, `getFacts` will retrieve a different</span></span>
<span id="cb9-9"><a href="#cb9-9"></a>    <span class="co">-- type of fact (all based on type information):</span></span>
<span id="cb9-10"><a href="#cb9-10"></a>    result <span class="ot">&lt;-</span> <span class="dt">AnalysisResult</span> <span class="op">&lt;$&gt;</span> S.getFacts prog</span>
<span id="cb9-11"><a href="#cb9-11"></a>                             <span class="op">&lt;*&gt;</span> S.getFacts prog</span>
<span id="cb9-12"><a href="#cb9-12"></a>                             <span class="op">&lt;*&gt;</span> S.getFacts prog</span>
<span id="cb9-13"><a href="#cb9-13"></a>    <span class="co">-- etc...</span></span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>In today's post, I showed how you can use Datalog from your Haskell code to perform complex analyses. By first destructuring an analysis in terms of simple facts and then writing queries based on those facts, we can write our analyses in a way close to how we reason about our code.</p>
<p>In this article we focused on an analysis for a simple language, but this approach is not limited to this usecase. For example, you can also use it for when you need to process complex data in a webserver, in data science, ...</p>
<p>If you want to see a more complicated example of this approach, here's a <a href="https://github.com/luc-tielen/playground/blob/dead_code_elimination/src/Main.hs">dead code elimination</a> analysis. This example is more complicated than the one explained in this post and uses techniques like control flow analysis (in Datalog) to compute all dead code paths in a program. And if you really want to go all-in, you could structure your different analyses to gather all facts in a single traversal by <a href="/posts/combining_folds_using_semigroups">combining them into one fold</a>.</p>
<p>If you have any questions or thoughts about this article, let me know on <a href="https://twitter.com/luctielen/status/1418954922209460236">Twitter</a>. If you want to play around with the code from this post, it can be found <a href="https://github.com/luc-tielen/playground/blob/static_analysis_blogpost/src/Main.hs">here</a>.</p>
    <img src="https://api.stathat.com/c?ukey=MTk2NzAgWkL6UC1F__NJ8FQSQf0CiA~~&key=27ZUKzMSpTwf7JNpDPdlHiA0WVlO&count=1"
         style="display:none;" width="1" height="1"/>
  </main>
</body>
