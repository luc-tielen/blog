<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Luc&#39;s personal blog</title>
    <link href="https://luctielen.com/atom.xml" rel="self" type="application/rss+xml" />
  <updated>2021-01-12T17:26:SZ</updated>
  <author>
      <name>Luc Tielen</name>
  </author>
  <id>https://luctielen.com/</id>

  <entry>
      <title>Calling C++ from Haskell</title>
      <link href="https://luctielen.com/posts/calling_cpp_from_haskell"/>
      <id>https://luctielen.com/posts/calling_cpp_from_haskell</id>
      <updated>2021-01-12T00:00:SZ</updated>
      <category term="haskell"/>
      <category term="c++"/>
      <summary></summary>
      <content type="html"><![CDATA[<p>In today's blogpost, I will show an approach for calling C++ code from Haskell. This can be useful in case you need the extra performance from C++ or if there is no library in the Haskell ecosystem that provides the functionality you need (but there is a C++ library for it).</p>
<p>The code snippets in this article are kept "simple" (though I will assume some C++ knowledge, since you will need to write some extra C++ code when binding to Haskell). The examples are derived from my <a href="https://github.com/luc-tielen/souffle-haskell.git">souffle-haskell library</a>, where I had to write Haskell bindings to interact with the Soufflé datalog language.</p>
<h2 id="binding-to-c">Binding to C++</h2>
<p>If a library is meant to be used from many other languages, most of the time it will provide a C API for doing so. C has a relatively small feature-set and a well-defined, stable ABI (binary interface). On top of that, most languages have good support for interacting with C via a foreign function interface (FFI), making it straight-forward to interface with C.</p>
<p>However, for some libraries this is not the case. Soufflé for example provides only a <a href="https://souffle-lang.github.io/interface">C++ interface</a>. C++ is a lot bigger language compared to C, has no stable ABI between different versions / compilers and contains many complex features such as overloadable functions and operators, templates, destructors, ... This makes binding to it a lot more complicated than C.</p>
<p>The trick is to write an extra layer between the existing Haskell and C++ code, that exposes functionality using the C ABI. Fortunately, C++ offers an easy way to be compatible with the C ABI with the <em>extern</em> keyword. The snippet below defines a function "answer_to_everything" that can be called from C (and thus also from other languages!):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> {</span>
<span id="cb1-2"><a href="#cb1-2"></a>  <span class="dt">int</span> answer_to_everything(<span class="dt">bool</span> arg);</span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a>  <span class="dt">int</span> answer_to_everything(<span class="dt">bool</span> arg) {</span>
<span id="cb1-5"><a href="#cb1-5"></a>    <span class="cf">return</span> <span class="dv">42</span>;</span>
<span id="cb1-6"><a href="#cb1-6"></a>  }</span>
<span id="cb1-7"><a href="#cb1-7"></a>}</span></code></pre></div>
<p>When using extern, you can still use C++-specific functionality inside the body of a function, but the signature of the function needs to be compatible with C.</p>
<p>If you wanted to, you could now start using this function in Haskell after importing it with a so-called <em>foreign import</em>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a>foreign <span class="kw">import</span> ccall unsafe &quot;answer_to_everything&quot; answerToEverything</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="ot">  ::</span> <span class="dt">CBool</span> <span class="ot">-&gt;</span> <span class="dt">CInt</span></span></code></pre></div>
<p>A foreign import is Haskell's way of importing C-compatible functions. Note that unlike Haskell modules, you will need to import foreign functions on a per-function basis. The syntax is as follows:</p>
<ul>
<li><em>foreign import ccall</em>: We're importing a foreign function!</li>
<li><em>unsafe</em>: This tells the Haskell compiler that the foreign function will not call back into Haskell. This results in less overhead when crossing language boundaries but you should only use the keyword when this is really the case!</li>
<li><em>"answer_to_everything"</em>: The name of the function (as defined in C++)</li>
<li>_answerToEverything: The name of the function (in Haskell)</li>
<li>Type signature: You need to manually add a type signature here, using the types defined in <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-C-Types.html">Foreign.C.Types</a>. Depending on if the function is pure or not, you also should wrap the result in IO. The Haskell compiler blindly trusts you as a programmer to provide the correct signature. If you make a mistake here, <em>bad things will happen</em><span class="emoji" data-emoji="tm">™️</span>, so be sure to get it right.</li>
</ul>
<h3 id="memory-management-and-objects">Memory management and objects</h3>
<p>Now that we know how to cross the language border and use a simple C++ function from Haskell, we can focus on other more complicated concepts.</p>
<p>First of all, there's memory management. Haskell uses a a garbage collector to clean up unused memory automatically. This is in contrast with C++, which is much "closer to the metal". C++ gives you very fine-grained control of the memory layout of an object and when exactly to allocate or free the memory of an object. If we want to bind C++ to Haskell, <strong>we have to make sure both languages work well together</strong>. One way to achieve this is by letting Haskell be in charge and call into the C++ code. Objects used via the FFI need to be allocated on the C++ heap, so they don't automatically get cleaned up once the object goes out of scope (like stack-allocated objects would). After objects are no longer in use, they need to be cleaned up again (also from the Haskell side).</p>
<p>The next issue are <em>the objects themselves</em>. The C ABI has no support for objects or calling methods on those objects. This isn't a problem though, since objects can be represented as an (opaque) C-like struct, together with functions that perform actions with that struct. Each of the functions has the same signature as the corresponding method of the object, except the function takes an additional argument for the pointer to the object. (In C++ this is handled implicitly for you with the <em>this</em> pointer.) Constructors and destructors also need to have their own separate functions in the FFI.</p>
<p>Taking all this into account, our FFI layer for managing a C++ object could look like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">// Suppose we want to call into this object from Haskell:</span></span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="kw">class</span> Example {</span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="kw">public</span>:</span>
<span id="cb3-5"><a href="#cb3-5"></a>  <span class="co">// Note: Constructor and destructor are auto-generated here!</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>  <span class="co">// We will have to add functions for calling these as well.</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>  <span class="dt">bool</span> do_stuff(<span class="dt">int</span> arg);</span>
<span id="cb3-8"><a href="#cb3-8"></a>};</span>
<span id="cb3-9"><a href="#cb3-9"></a></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="co">// We can define the following FFI layer:</span></span>
<span id="cb3-11"><a href="#cb3-11"></a></span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="co">// in ffi.h</span></span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> {</span>
<span id="cb3-14"><a href="#cb3-14"></a>  <span class="kw">typedef</span> <span class="kw">struct</span> ffi_example;</span>
<span id="cb3-15"><a href="#cb3-15"></a></span>
<span id="cb3-16"><a href="#cb3-16"></a>  ffi_example* example_create();</span>
<span id="cb3-17"><a href="#cb3-17"></a>  <span class="dt">void</span> example_destroy(ffi_example* object);</span>
<span id="cb3-18"><a href="#cb3-18"></a>  <span class="dt">bool</span> example_do_stuff(ffi_example* object, <span class="dt">int</span> arg);</span>
<span id="cb3-19"><a href="#cb3-19"></a>}</span>
<span id="cb3-20"><a href="#cb3-20"></a></span>
<span id="cb3-21"><a href="#cb3-21"></a><span class="co">// in ffi.cpp</span></span>
<span id="cb3-22"><a href="#cb3-22"></a><span class="pp">#include </span><span class="im">&quot;ffi.h&quot;</span></span>
<span id="cb3-23"><a href="#cb3-23"></a></span>
<span id="cb3-24"><a href="#cb3-24"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> {</span>
<span id="cb3-25"><a href="#cb3-25"></a></span>
<span id="cb3-26"><a href="#cb3-26"></a>ffi_example* example_create() {</span>
<span id="cb3-27"><a href="#cb3-27"></a>  <span class="kw">auto</span> object = <span class="kw">new</span> Example();</span>
<span id="cb3-28"><a href="#cb3-28"></a>  <span class="cf">return</span> <span class="kw">reinterpret_cast</span>&lt;ffi_example*&gt;(object);</span>
<span id="cb3-29"><a href="#cb3-29"></a>}</span>
<span id="cb3-30"><a href="#cb3-30"></a></span>
<span id="cb3-31"><a href="#cb3-31"></a><span class="dt">void</span> example_destroy(ffi_example* object) {</span>
<span id="cb3-32"><a href="#cb3-32"></a>  <span class="kw">auto</span> example = <span class="kw">reinterpret_cast</span>&lt;Example*&gt;(object);</span>
<span id="cb3-33"><a href="#cb3-33"></a>  <span class="kw">delete</span> example;</span>
<span id="cb3-34"><a href="#cb3-34"></a>}</span>
<span id="cb3-35"><a href="#cb3-35"></a></span>
<span id="cb3-36"><a href="#cb3-36"></a><span class="dt">bool</span> example_do_stuff(ffi_example* object, <span class="dt">int</span> arg) {</span>
<span id="cb3-37"><a href="#cb3-37"></a>  <span class="kw">auto</span> example = <span class="kw">reinterpret_cast</span>&lt;Example*&gt;(object);</span>
<span id="cb3-38"><a href="#cb3-38"></a>  <span class="cf">return</span> example-&gt;do_stuff(arg);</span>
<span id="cb3-39"><a href="#cb3-39"></a>}</span>
<span id="cb3-40"><a href="#cb3-40"></a></span>
<span id="cb3-41"><a href="#cb3-41"></a>}</span></code></pre></div>
<p>Now that we have the C++ part, we still need to write the Haskell part. To do this, we use an API from the Haskell <em>base</em> library for interacting with foreign functions. It provides data types that have a 1-to-1 correspondence with their C equivalents (for example <em>CInt</em>, <em>CBool</em>, ...). The <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-Ptr.html#t:Ptr">Ptr</a> data type is used for managing pointers from Haskell. The <em>Ptr</em> type uses a phantom type variable as a type-level tag to detect at compile time if you use a pointer of an unexpected type.</p>
<p>You may have noticed in the last C++ snippet that there was a manual call to <em>delete</em>. This is frowned upon in C++ nowadays since it can be very easy to make a mistake and forget to call <em>delete</em> in certain code paths (for example if an exception occurred). C++ has a solution for this in the form of so-called <em>smart pointers</em> but those are unusable in combination with the FFI. Haskell has a very similar mechanism though, called <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-ForeignPtr.html#t:ForeignPtr">foreign pointers</a>. A foreign pointer is a pointer managed by the Haskell runtime / garbage collector, coupled with a finalizer function for freeing up the memory used by the pointer. When the foreign pointer goes out of scope and there are no more references to it in the Haskell runtime, it will call the finalizer function.</p>
<p>Continuing with the <em>Example</em> class from earlier, we can now make sure the destructor is always called when the object goes out of scope:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="co">-- An empty data type, used as a type tag for the Ptr type</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="kw">data</span> <span class="dt">Example</span></span>
<span id="cb4-3"><a href="#cb4-3"></a></span>
<span id="cb4-4"><a href="#cb4-4"></a>foreign <span class="kw">import</span> ccall unsafe &quot;example_create&quot; exampleCreate</span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="ot">  ::</span> <span class="dt">IO</span> (<span class="dt">Ptr</span> <span class="dt">Example</span>)</span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="co">-- Slightly different syntax, this gives us a function pointer to the</span></span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="co">-- &quot;example_destroy&quot; function (needed below):</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>foreign <span class="kw">import</span> ccall unsafe &quot;&amp;example_destroy&quot; exampleDestroy</span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="ot">  ::</span> <span class="dt">FunPtr</span> (<span class="dt">Ptr</span> <span class="dt">Example</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ())</span>
<span id="cb4-10"><a href="#cb4-10"></a>foreign <span class="kw">import</span> ccall unsafe &quot;example_do_stuff&quot; exampleDoStuff</span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="ot">  ::</span> <span class="dt">Ptr</span> <span class="dt">Example</span> <span class="ot">-&gt;</span> <span class="dt">CInt</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">CBool</span></span>
<span id="cb4-12"><a href="#cb4-12"></a></span>
<span id="cb4-13"><a href="#cb4-13"></a><span class="co">-- This initializes a Example object on the heap, that will be</span></span>
<span id="cb4-14"><a href="#cb4-14"></a><span class="co">-- cleaned up with &quot;exampleDestroy&quot; when it is no longer in use.</span></span>
<span id="cb4-15"><a href="#cb4-15"></a><span class="ot">mkExample ::</span> <span class="dt">IO</span> (<span class="dt">ForeignPtr</span> <span class="dt">Example</span>)</span>
<span id="cb4-16"><a href="#cb4-16"></a>mkExample <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-17"><a href="#cb4-17"></a>  ptr <span class="ot">&lt;-</span> exampleCreate</span>
<span id="cb4-18"><a href="#cb4-18"></a>  newForeignPtr exampleDestroy ptr</span>
<span id="cb4-19"><a href="#cb4-19"></a></span>
<span id="cb4-20"><a href="#cb4-20"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb4-21"><a href="#cb4-21"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-22"><a href="#cb4-22"></a>  obj <span class="ot">&lt;-</span> mkExample</span>
<span id="cb4-23"><a href="#cb4-23"></a>  <span class="co">-- Now we can use the pointer by unwrapping it with &quot;withForeignPtr&quot;:</span></span>
<span id="cb4-24"><a href="#cb4-24"></a>  withForeignPtr obj <span class="op">$</span> \ptr <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb4-25"><a href="#cb4-25"></a>    result <span class="ot">&lt;-</span> exampleDoStuff ptr <span class="dv">1234</span></span>
<span id="cb4-26"><a href="#cb4-26"></a>    <span class="fu">print</span> result  <span class="co">-- Process the result.</span></span></code></pre></div>
<h3 id="overloads">Overloads</h3>
<p>C++ has support for <em>overloadable functions</em> (functions with the same name and scope, but with different type signatures and function bodies). However, this is again not supported in C and as such is not possible to do in the FFI. If we want to be able to call these overloads, we have to wrap each variant with a helper function that is exposed in the FFI. If we add an overload to our Example class defined earlier, we can expose overloaded functions as follows:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">class</span> Example {</span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="kw">public</span>:</span>
<span id="cb5-3"><a href="#cb5-3"></a>  <span class="dt">bool</span> do_stuff(<span class="dt">int</span> arg);</span>
<span id="cb5-4"><a href="#cb5-4"></a>  <span class="dt">bool</span> do_stuff(<span class="dt">float</span> arg);  <span class="co">// &lt;- This overload is new.</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>};</span>
<span id="cb5-6"><a href="#cb5-6"></a></span>
<span id="cb5-7"><a href="#cb5-7"></a></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="co">// in ffi.h</span></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> {</span>
<span id="cb5-10"><a href="#cb5-10"></a>  <span class="co">// Rest of code is same as before.</span></span>
<span id="cb5-11"><a href="#cb5-11"></a></span>
<span id="cb5-12"><a href="#cb5-12"></a>  <span class="co">// The FFI functions all need a unique name.</span></span>
<span id="cb5-13"><a href="#cb5-13"></a>  <span class="dt">bool</span> example_do_stuff_int(ffi_example* object, <span class="dt">int</span> arg);</span>
<span id="cb5-14"><a href="#cb5-14"></a>  <span class="dt">bool</span> example_do_stuff_float(ffi_example* object, <span class="dt">float</span> arg);</span>
<span id="cb5-15"><a href="#cb5-15"></a>  <span class="co">// ... add other variants as needed.</span></span>
<span id="cb5-16"><a href="#cb5-16"></a>}</span>
<span id="cb5-17"><a href="#cb5-17"></a></span>
<span id="cb5-18"><a href="#cb5-18"></a><span class="co">// in ffi.cpp</span></span>
<span id="cb5-19"><a href="#cb5-19"></a><span class="pp">#include </span><span class="im">&quot;ffi.h&quot;</span></span>
<span id="cb5-20"><a href="#cb5-20"></a></span>
<span id="cb5-21"><a href="#cb5-21"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> {</span>
<span id="cb5-22"><a href="#cb5-22"></a><span class="co">// Rest of code is same as before.</span></span>
<span id="cb5-23"><a href="#cb5-23"></a></span>
<span id="cb5-24"><a href="#cb5-24"></a><span class="dt">bool</span> example_do_stuff_int(ffi_example* object, <span class="dt">int</span> arg) {</span>
<span id="cb5-25"><a href="#cb5-25"></a>  <span class="kw">auto</span> example = <span class="kw">reinterpret_cast</span>&lt;Example*&gt;(object);</span>
<span id="cb5-26"><a href="#cb5-26"></a>  <span class="cf">return</span> example-&gt;do_stuff(arg);  <span class="co">// calls the overload with int argument</span></span>
<span id="cb5-27"><a href="#cb5-27"></a>}</span>
<span id="cb5-28"><a href="#cb5-28"></a></span>
<span id="cb5-29"><a href="#cb5-29"></a><span class="dt">bool</span> example_do_stuff_float(ffi_example* object, <span class="dt">float</span> arg) {</span>
<span id="cb5-30"><a href="#cb5-30"></a>  <span class="kw">auto</span> example = <span class="kw">reinterpret_cast</span>&lt;Example*&gt;(object);</span>
<span id="cb5-31"><a href="#cb5-31"></a>  <span class="cf">return</span> example-&gt;do_stuff(arg);  <span class="co">// calls the overload with float argument</span></span>
<span id="cb5-32"><a href="#cb5-32"></a>}</span>
<span id="cb5-33"><a href="#cb5-33"></a></span>
<span id="cb5-34"><a href="#cb5-34"></a>}</span></code></pre></div>
<p>Finally, each variant has to be imported on the Haskell side:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="co">-- Rest of code is same as before.</span></span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a>foreign <span class="kw">import</span> ccall unsafe &quot;example_do_stuff_int&quot; exampleDoStuffInt</span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="ot">  ::</span> <span class="dt">Ptr</span> <span class="dt">Example</span> <span class="ot">-&gt;</span> <span class="dt">CInt</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">CBool</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>foreign <span class="kw">import</span> ccall unsafe &quot;example_do_stuff_float&quot; exampleDoStuffFloat</span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="ot">  ::</span> <span class="dt">Ptr</span> <span class="dt">Example</span> <span class="ot">-&gt;</span> <span class="dt">CFloat</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">CBool</span></span></code></pre></div>
<h3 id="loops">Loops</h3>
<p>So far we focused on a single object or data type, but what about multiple objects? In C++ for- or while-loops are used to iterate over collections of data. Loops, like the other concepts mentioned before, will require some massaging into a different format until we have something that can be used from the FFI.</p>
<p>Let's update our previous example to have a collection of some sort:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">class</span> Example {</span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="kw">private</span>:</span>
<span id="cb7-3"><a href="#cb7-3"></a>  <span class="co">// Example now contains a collection of data</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>  <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; values;</span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="kw">public</span>:</span>
<span id="cb7-7"><a href="#cb7-7"></a>  <span class="co">// To keep things simple, we initialize the vector to</span></span>
<span id="cb7-8"><a href="#cb7-8"></a>  <span class="co">// a collection of 3 hardcoded values.</span></span>
<span id="cb7-9"><a href="#cb7-9"></a>  Example() : values({<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>}) {}</span>
<span id="cb7-10"><a href="#cb7-10"></a></span>
<span id="cb7-11"><a href="#cb7-11"></a>  <span class="kw">auto</span>&amp; get_values() <span class="at">const</span> {</span>
<span id="cb7-12"><a href="#cb7-12"></a>      <span class="cf">return</span> values;</span>
<span id="cb7-13"><a href="#cb7-13"></a>  }</span>
<span id="cb7-14"><a href="#cb7-14"></a>};</span>
<span id="cb7-15"><a href="#cb7-15"></a></span>
<span id="cb7-16"><a href="#cb7-16"></a></span>
<span id="cb7-17"><a href="#cb7-17"></a><span class="co">// We can now loop over the data:</span></span>
<span id="cb7-18"><a href="#cb7-18"></a></span>
<span id="cb7-19"><a href="#cb7-19"></a>Example example;</span>
<span id="cb7-20"><a href="#cb7-20"></a><span class="kw">auto</span>&amp; values = example.get_values();</span>
<span id="cb7-21"><a href="#cb7-21"></a></span>
<span id="cb7-22"><a href="#cb7-22"></a><span class="cf">for</span> (<span class="kw">auto</span>&amp; value : values) {</span>
<span id="cb7-23"><a href="#cb7-23"></a>  process_value(value);</span>
<span id="cb7-24"><a href="#cb7-24"></a>}</span></code></pre></div>
<p>The example makes use of a range-based for-loop, which was introduced in C++11. Range-based loops are a form of syntactic sugar and can be rewritten using C++ iterators as follows:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="co">// Note: &quot;it&quot; is short for iterator</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="cf">for</span> (<span class="kw">auto</span> it = values.begin(); it != values.end(); ++it) {</span>
<span id="cb8-3"><a href="#cb8-3"></a>  <span class="kw">auto</span>&amp; value = *it;</span>
<span id="cb8-4"><a href="#cb8-4"></a>  process_value(value);</span>
<span id="cb8-5"><a href="#cb8-5"></a>}</span></code></pre></div>
<p>While we're at it, a standard for-loop is also sugar for a while-loop. Let's do another transform:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">auto</span> it = values.begin();</span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="cf">while</span> (it != values.end()) {</span>
<span id="cb9-3"><a href="#cb9-3"></a>  <span class="kw">auto</span>&amp; value = *it;</span>
<span id="cb9-4"><a href="#cb9-4"></a>  process_value(value);</span>
<span id="cb9-5"><a href="#cb9-5"></a>  ++it;</span>
<span id="cb9-6"><a href="#cb9-6"></a>}</span></code></pre></div>
<p>This is starting to come close to something that we can use from the FFI, we only need to write some functions for calling each of the steps of the loop separately:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">auto</span> it = ffi_iterator_create(values);</span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="cf">while</span> (ffi_iterator_has_next(it)) {</span>
<span id="cb10-3"><a href="#cb10-3"></a>  <span class="kw">auto</span>&amp; value = ffi_iterator_next(it);</span>
<span id="cb10-4"><a href="#cb10-4"></a>  <span class="bu">std::</span>cout &lt;&lt; value &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb10-5"><a href="#cb10-5"></a>}</span>
<span id="cb10-6"><a href="#cb10-6"></a>ffi_iterator_destroy(it);</span></code></pre></div>
<p>Writing each of the helper functions is quite a bit of work, but is based on ideas mentioned earlier in this blogpost:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="co">// in ffi.h</span></span>
<span id="cb11-2"><a href="#cb11-2"></a></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="kw">struct</span> ffi_iterator;  <span class="co">// New struct for iterating over the collection.</span></span>
<span id="cb11-4"><a href="#cb11-4"></a></span>
<span id="cb11-5"><a href="#cb11-5"></a>ffi_iterator* ffi_iterator_create(ffi_example* obj);</span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="dt">void</span> ffi_iterator_destroy(ffi_iterator* it);</span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="dt">bool</span> ffi_iterator_has_next(ffi_iterator* it);</span>
<span id="cb11-8"><a href="#cb11-8"></a><span class="dt">int</span> ffi_iterator_next(ffi_iterator* it);</span>
<span id="cb11-9"><a href="#cb11-9"></a></span>
<span id="cb11-10"><a href="#cb11-10"></a></span>
<span id="cb11-11"><a href="#cb11-11"></a><span class="co">// in ffi.cpp</span></span>
<span id="cb11-12"><a href="#cb11-12"></a></span>
<span id="cb11-13"><a href="#cb11-13"></a><span class="kw">struct</span> ffi_iterator {</span>
<span id="cb11-14"><a href="#cb11-14"></a>  <span class="kw">using</span> <span class="dt">iterator_t</span> = <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;::iterator;</span>
<span id="cb11-15"><a href="#cb11-15"></a></span>
<span id="cb11-16"><a href="#cb11-16"></a>  <span class="co">// We need to keep track of what the iterator is currently pointing to,</span></span>
<span id="cb11-17"><a href="#cb11-17"></a>  <span class="co">// as well as the end of the collection.</span></span>
<span id="cb11-18"><a href="#cb11-18"></a>  <span class="dt">iterator_t</span> iterator;</span>
<span id="cb11-19"><a href="#cb11-19"></a>  <span class="at">const</span> <span class="dt">iterator_t</span> end;</span>
<span id="cb11-20"><a href="#cb11-20"></a></span>
<span id="cb11-21"><a href="#cb11-21"></a>  ffi_iterator(<span class="at">const</span> <span class="dt">iterator_t</span>&amp; <span class="va">begin_</span>, <span class="at">const</span> <span class="dt">iterator_t</span>&amp; <span class="va">end_</span>)</span>
<span id="cb11-22"><a href="#cb11-22"></a>    : iterator(<span class="va">begin_</span>)</span>
<span id="cb11-23"><a href="#cb11-23"></a>    , end(<span class="va">end_</span>) {}</span>
<span id="cb11-24"><a href="#cb11-24"></a>};</span>
<span id="cb11-25"><a href="#cb11-25"></a></span>
<span id="cb11-26"><a href="#cb11-26"></a>ffi_iterator* ffi_iterator_create(ffi_example* obj) {</span>
<span id="cb11-27"><a href="#cb11-27"></a>  <span class="co">// We get the collection out of the object,</span></span>
<span id="cb11-28"><a href="#cb11-28"></a>  <span class="co">// and get the iterators pointing to beginning and end.</span></span>
<span id="cb11-29"><a href="#cb11-29"></a>  <span class="kw">auto</span> example = <span class="kw">reinterpret_cast</span>&lt;Example*&gt;(obj);</span>
<span id="cb11-30"><a href="#cb11-30"></a>  <span class="kw">auto</span>&amp; values = example.get_values();</span>
<span id="cb11-31"><a href="#cb11-31"></a>  <span class="cf">return</span> <span class="kw">new</span> ffi_iterator(values.begin(), values.end());</span>
<span id="cb11-32"><a href="#cb11-32"></a>}</span>
<span id="cb11-33"><a href="#cb11-33"></a></span>
<span id="cb11-34"><a href="#cb11-34"></a><span class="dt">void</span> ffi_iterator_destroy(ffi_iterator* it) {</span>
<span id="cb11-35"><a href="#cb11-35"></a>  <span class="kw">delete</span> it;</span>
<span id="cb11-36"><a href="#cb11-36"></a>}</span>
<span id="cb11-37"><a href="#cb11-37"></a></span>
<span id="cb11-38"><a href="#cb11-38"></a><span class="dt">bool</span> ffi_iterator_has_next(ffi_iterator* it) {</span>
<span id="cb11-39"><a href="#cb11-39"></a>  <span class="co">// There is a next value if the iterator is not pointing to the end.</span></span>
<span id="cb11-40"><a href="#cb11-40"></a>  <span class="cf">return</span> it-&gt;iterator != it-&gt;end;</span>
<span id="cb11-41"><a href="#cb11-41"></a>}</span>
<span id="cb11-42"><a href="#cb11-42"></a></span>
<span id="cb11-43"><a href="#cb11-43"></a><span class="dt">int</span> ffi_iterator_next(ffi_iterator* it) {</span>
<span id="cb11-44"><a href="#cb11-44"></a>  <span class="co">// Get the current element, then update iterator to next element.</span></span>
<span id="cb11-45"><a href="#cb11-45"></a>  <span class="kw">auto</span>&amp; value = *it-&gt;iterator;</span>
<span id="cb11-46"><a href="#cb11-46"></a>  ++it-&gt;iterator;</span>
<span id="cb11-47"><a href="#cb11-47"></a>  <span class="cf">return</span> value;</span>
<span id="cb11-48"><a href="#cb11-48"></a>}</span></code></pre></div>
<p>Once we have these functions, we can build our own loop in Haskell and process the values there:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">data</span> <span class="dt">ExampleIterator</span></span>
<span id="cb12-2"><a href="#cb12-2"></a></span>
<span id="cb12-3"><a href="#cb12-3"></a>foreign <span class="kw">import</span> ccall unsafe &quot;ffi_iterator_create&quot; ffiIteratorCreate</span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="ot">  ::</span> <span class="dt">Ptr</span> <span class="dt">Example</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Ptr</span> <span class="dt">ExampleIterator</span>)</span>
<span id="cb12-5"><a href="#cb12-5"></a>foreign <span class="kw">import</span> ccall unsafe &quot;&amp;ffi_iterator_destroy&quot; ffiIteratorDestroy</span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="ot">  ::</span> <span class="dt">FunPtr</span> (<span class="dt">Ptr</span> <span class="dt">ExampleIterator</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ())</span>
<span id="cb12-7"><a href="#cb12-7"></a>foreign <span class="kw">import</span> ccall unsafe &quot;ffi_iterator_has_next&quot; ffiIteratorHasNext</span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="ot">  ::</span> <span class="dt">Ptr</span> <span class="dt">ExampleIterator</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">CBool</span></span>
<span id="cb12-9"><a href="#cb12-9"></a>foreign <span class="kw">import</span> ccall unsafe &quot;ffi_iterator_next&quot; ffiIteratorNext</span>
<span id="cb12-10"><a href="#cb12-10"></a><span class="ot">  ::</span> <span class="dt">Ptr</span> <span class="dt">ExampleIterator</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">CInt</span></span>
<span id="cb12-11"><a href="#cb12-11"></a></span>
<span id="cb12-12"><a href="#cb12-12"></a></span>
<span id="cb12-13"><a href="#cb12-13"></a><span class="ot">mkExampleIterator ::</span> <span class="dt">Ptr</span> <span class="dt">Example</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">ForeignPtr</span> <span class="dt">ExampleIterator</span>)</span>
<span id="cb12-14"><a href="#cb12-14"></a>mkExampleIterator ptr <span class="ot">=</span></span>
<span id="cb12-15"><a href="#cb12-15"></a>  newForeignPtr ffiIteratorDestroy <span class="op">=&lt;&lt;</span> ffiIteratorCreate ptr</span>
<span id="cb12-16"><a href="#cb12-16"></a></span>
<span id="cb12-17"><a href="#cb12-17"></a><span class="co">-- Helper function for looping over the data and collecting the results on</span></span>
<span id="cb12-18"><a href="#cb12-18"></a><span class="co">-- the Haskell side.</span></span>
<span id="cb12-19"><a href="#cb12-19"></a><span class="ot">collectValues ::</span> <span class="dt">Ptr</span> <span class="dt">ExampleIterator</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">CInt</span>]</span>
<span id="cb12-20"><a href="#cb12-20"></a>collectValues <span class="ot">=</span> go [] <span class="kw">where</span></span>
<span id="cb12-21"><a href="#cb12-21"></a>  go acc iterator <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-22"><a href="#cb12-22"></a>    <span class="dt">CBool</span> hasNext <span class="ot">&lt;-</span> ffiIteratorHasNext iterator</span>
<span id="cb12-23"><a href="#cb12-23"></a>    <span class="kw">if</span> hasNext <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb12-24"><a href="#cb12-24"></a>      <span class="kw">then</span> <span class="kw">do</span></span>
<span id="cb12-25"><a href="#cb12-25"></a>        value <span class="ot">&lt;-</span> ffiIteratorNext iterator</span>
<span id="cb12-26"><a href="#cb12-26"></a>        go (value <span class="op">:</span> acc) iterator</span>
<span id="cb12-27"><a href="#cb12-27"></a>      <span class="kw">else</span> <span class="fu">pure</span> acc</span>
<span id="cb12-28"><a href="#cb12-28"></a></span>
<span id="cb12-29"><a href="#cb12-29"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb12-30"><a href="#cb12-30"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-31"><a href="#cb12-31"></a>  obj <span class="ot">&lt;-</span> mkExample</span>
<span id="cb12-32"><a href="#cb12-32"></a>  withForeignPtr obj <span class="op">$</span> \objPtr <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-33"><a href="#cb12-33"></a>    iterator <span class="ot">&lt;-</span> mkExampleIterator objPtr</span>
<span id="cb12-34"><a href="#cb12-34"></a>    withForeignPtr iterator <span class="op">$</span> \iteratorPtr <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-35"><a href="#cb12-35"></a>      values <span class="ot">&lt;-</span> collectValues iteratorPtr</span>
<span id="cb12-36"><a href="#cb12-36"></a>      <span class="co">-- Now you can process the values like you would</span></span>
<span id="cb12-37"><a href="#cb12-37"></a>      <span class="co">-- for any other Haskell value.</span></span>
<span id="cb12-38"><a href="#cb12-38"></a>      <span class="fu">print</span> <span class="op">$</span> <span class="fu">map</span> (<span class="op">+</span><span class="dv">1</span>) values</span></code></pre></div>
<h3 id="compiler-flags">Compiler flags</h3>
<p>That's it for the code part, but we're not finished quite yet! Because we are using 2 languages, we need to provide compilation flags for both Haskell and C++. This can be done in your project's package.yaml / cabal file / stack.yaml.</p>
<p>For example, in the souffle-haskell library, the package.yaml contains additional configuration instructing the C++ compiler to look for files in the <em>cbits</em> directory and use the given C++ compiler flags:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb13-1"><a href="#cb13-1"></a><span class="fu">cxx-sources</span><span class="kw">:</span><span class="at"> cbits/*.cpp</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="fu">include-dirs</span><span class="kw">:</span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="at">  </span><span class="kw">-</span><span class="at"> cbits</span></span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="at">  </span><span class="kw">-</span><span class="at"> cbits/souffle</span></span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="fu">cxx-options</span><span class="kw">:</span></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="at">  </span><span class="kw">-</span><span class="at"> -std=c++17</span></span>
<span id="cb13-7"><a href="#cb13-7"></a><span class="co">  # Provide other C++ compilation flags here as necessary.</span></span></code></pre></div>
<p>Note that you should not use <em>cpp-options</em> in the yaml file. This refers to the Haskell C-preprocessor config and does not refer to C++-options like I initially assumed.</p>
<p>Depending on the C++ code you are binding to, you may also need to add specific compiler flags for certain C++ compilers or operating systems. In package.yaml this can be done as follows:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb14-1"><a href="#cb14-1"></a><span class="fu">when</span><span class="kw">:</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="at">  </span><span class="kw">-</span><span class="at"> </span><span class="fu">condition</span><span class="kw">:</span><span class="at"> os(darwin)</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="at">    </span><span class="fu">extra-libraries</span><span class="kw">:</span><span class="at"> c++</span></span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>This post turned out <em>much</em> larger than I initially expected! I guess this shows that binding to C++ is more work than C, but can definitely be done. The code in some snippets is simplified to avoid making this blog post even longer. If you are interested in what a "real" example of this approach looks like, check out my <a href="https://github.com/luc-tielen/souffle-haskell">souffle-haskell library</a>. You can find the most relevant files for binding to C++ <a href="https://github.com/luc-tielen/souffle-haskell/blob/master/cbits/souffle.cpp">here</a>, <a href="https://github.com/luc-tielen/souffle-haskell/blob/master/lib/Language/Souffle/Internal/Bindings.hs">here</a> and <a href="https://github.com/luc-tielen/souffle-haskell/blob/master/lib/Language/Souffle/Internal.hs">here</a>.</p>
<p>One final thing to mention is that this approach isn't specific to Haskell, you would only need to swap out the Haskell code with your language of choice to bind to the underlying C++ code.</p>
<p>If you are interested in more content like this, follow me on <a href="https://twitter.com/luctielen">Twitter</a> for blogpost updates or subscribe to the <a href="https://luctielen.com/atom.xml">RSS feed</a>.</p>]]></content>
  </entry>
  <entry>
      <title>How to set up your blog with Haskell, Slick and Netlify</title>
      <link href="https://luctielen.com/posts/how_to_setup_blog_with_haskell_slick_and_netlify"/>
      <id>https://luctielen.com/posts/how_to_setup_blog_with_haskell_slick_and_netlify</id>
      <updated>2020-12-21T00:00:SZ</updated>
      <category term="blog"/>
      <summary></summary>
      <content type="html"><![CDATA[<p>I wanted to setup a blog powered by Haskell and HTML/CSS and host it on Netlify. Creating a static site is easy enough using <em>Slick</em>, but this has no direct support for Netlify. In this first post I will show you how to fix that.</p>
<h2 id="tech-stack">Tech stack</h2>
<p>I wanted my blog to be easy to setup, minimal and extensible. In the past I've tried (and failed) setting up a blog because I never managed to finish the initial setup due to a complicated setup. After some googling around, I came across the <a href="https://hackage.haskell.org/package/slick">Slick static site generator</a>. Slick is written in Haskell and uses Pandoc + the Shake build system to compile all files into a static site. Slick assumes some Haskell knowledge but with the documentation you can have a first version of your blog up and running in a few minutes if you use the <a href="https://github.com/ChrisPenner/slick-template">default project template</a>.</p>
<p>After I got the blog up and running, it was time to give the website it's own look and feel. I started with a standalone HTML and CSS file and played around with the styling. Once I was happy with how the site looked, I replaced the templates and CSS that Slick provides by default with my own. The code for this blog can be found on <a href="https://github.com/luc-tielen/blog.git">Github</a>. The "site/" directory contains all templates / CSS / markdown used to generate this blog.</p>
<p>Generating the blog is as simple as running the following command:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1"></a>$ <span class="ex">stack</span> run</span></code></pre></div>
<p>This will put the generated files in the output folder you configured in "app/Main.hs".</p>
<h2 id="deploying-the-site">Deploying the site</h2>
<p>Now that I had the blog up and running, I still needed to deploy it somewhere. For this, I chose Netlify since it is often used for hosting static sites. Unfortunately though, Netlify has no direct support for Slick! To solve this, I wrote a small bash script that builds the blog and commits all necessary files from the blog into a separate orphan branch named "deploy":</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">#!/bin/bash</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="co"># Run this script locally to trigger a build and deploy.</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="co"># It assumes the &quot;deploy&quot; branch already exists</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co"># (create with &quot;git checkout --orphan deploy&quot;)</span></span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="kw">set</span> <span class="ex">-e</span></span>
<span id="cb2-8"><a href="#cb2-8"></a></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="bu">echo</span> <span class="st">&quot;Generating blog...&quot;</span></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="ex">stack</span> run</span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="fu">tar</span> czf build.tar.gz build/</span>
<span id="cb2-12"><a href="#cb2-12"></a></span>
<span id="cb2-13"><a href="#cb2-13"></a><span class="bu">echo</span> <span class="st">&quot;Updating blog content...&quot;</span></span>
<span id="cb2-14"><a href="#cb2-14"></a><span class="fu">git</span> checkout deploy</span>
<span id="cb2-15"><a href="#cb2-15"></a><span class="fu">rm</span> -rf build/</span>
<span id="cb2-16"><a href="#cb2-16"></a><span class="fu">tar</span> xzf build.tar.gz</span>
<span id="cb2-17"><a href="#cb2-17"></a><span class="fu">rm</span> build.tar.gz</span>
<span id="cb2-18"><a href="#cb2-18"></a></span>
<span id="cb2-19"><a href="#cb2-19"></a><span class="bu">echo</span> <span class="st">&quot;Deploying blog...&quot;</span></span>
<span id="cb2-20"><a href="#cb2-20"></a><span class="fu">git</span> add build/</span>
<span id="cb2-21"><a href="#cb2-21"></a><span class="fu">git</span> commit -m <span class="st">&#39;Deploy new version&#39;</span></span>
<span id="cb2-22"><a href="#cb2-22"></a><span class="fu">git</span> push</span>
<span id="cb2-23"><a href="#cb2-23"></a></span>
<span id="cb2-24"><a href="#cb2-24"></a><span class="fu">git</span> checkout -</span>
<span id="cb2-25"><a href="#cb2-25"></a></span>
<span id="cb2-26"><a href="#cb2-26"></a><span class="bu">exit</span> 0</span></code></pre></div>
<p>On the Netlify side, I configured it to trigger a deploy of the blog if a push was made to the "deploy" branch.</p>
<p>Last step was buying the domain name and linking it to my netlify app. I would suggest to buy the domain name via Netlify as well, for the easiest setup. For more information, see the <a href="https://docs.netlify.com/domains-https/custom-domains/#assign-a-domain-to-a-site">official Netlify docs</a>.</p>
<h2 id="whats-next">What's next?</h2>
<p>Phew, that was the first blogpost! If you followed along, you should now have your own blog setup! All that's left is to write some blogposts. <span class="emoji" data-emoji="smile">😄</span></p>
<p>So what can you expect on this blog in the future? Most content will be related to functional programming, compilers and logic, with maybe occassionally some other (non-)tech things. You can get updates on this blog if you follow me on <a href="https://twitter.com/luctielen">Twitter</a> or if you subscribe to my <a href="https://luctielen.com/atom.xml">RSS feed</a>.</p>
<p>Stay tuned!</p>]]></content>
  </entry>
</feed>
